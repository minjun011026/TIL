# 5장
데이터 중심 설계에서 책임 중심 설계로 전환하기 위해서는 다음의 2가지 원칙을 따라야 한다.
+ 데이터보다 행동을 먼저 결정하라
+ 협력이라는 문맥 안에서 책임을 결정하라

객체에게 할당된 품질은 협력에 적합한 정도로 결졍된다.   
만약 객체에게 할당된 책임이 어색해 보이더라도 협력에 적합하다면 그 책임은 좋은 것이다.

책에 다음과 같은 내용이 있다.
> “이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야 하지?”라고 질문하지 않고 “메시지를 전송해야 하는데 누구에게 전송해야 하지?”라고 질문하는 것. 설계의 핵심 질문을 이렇게 바꾸는 것이 메시지 기반 설계로 향하는 첫걸음이다.

메시지가 먼저다. 객체는 그 이후.

### 책임 주도 설계
+ 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
+ 시스템 책임을 더 작은 책임으로 분할한다.
+ 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
+ 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
+ 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

## 책임 할당을 위한 GRASP 패턴
GRASP는 General Responsibility Assignment Software Pattern의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

### 도메인 개념에서 출발하기
설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려보는 것이 유용하다.
이때 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없다.   
이 단계에서는 책임을 할당받을 객체들의 종류와 관계에 대한 유용한 정보를 제공할 수 있다면 충분하다.

> 올바른 도메인 모델이란 존재하지 않는다. 
> 
> 많은 사람들이 도메인 모델은 구현과는 무관하다고 생각하지만 이것은 도메인 모델의 개념을 오해한 것에 불과하다.
도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 돼야 한다. 이것은
도메인 모델이 구현을 염두에 두고 구조화되는 것이 바람직하다는 것을 의미한다. 반대로 코드의 구조가 도메인을
바라보는 관점을 바꾸기도 한다.

### 정보 전문가에게 책임을 할당하라
메시지는 메시지를 수신할 객체가 아닌 메시지를 전송할 객체의 의도를 반영해서 결정해야 한다.   
따라서 첫 질문은 다음과 같다.   

**"메시지를 전송할 객체는 무엇을 원하는가?"**

메시지를 결정했으므로 메시지에 적합한 객체를 선택해야 한다.
두 번재 질문은 다음과 같다.   

**"메시지를 수신할 적합한 객체는 누구인가?"**

두 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다   
-> 낮은 결합도 패턴, 높은 응집도 패턴

### 창조자에게 객체 생성 책임을 할당하라
GRASP의 CREATOR(창조자) 패턴 : 어떤 객체를 생성해야 할 때 어떤 객체에게 객채 생성 책임을 할당해야 하는가에 대한 지침   
객체 A를 생성해야 할 때 아래 조건을 최대한 많이 만족하는 B에게 객채 생성 책임을 할당하라.
+ B가 A 객체를 포함하거나 참조한다.
+ B가 A 객체를 기록한다.
+ B가 A 객체를 긴밀하게 사용한다.
+ B가 A 객체를 초기화하는데 필요한 데이터를 가지고 있다.(이 경우 B는 A에 대한 정보 전문가다.)

## 구현을 통한 검증
설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다고 한다.   
그렇다면 어떻게 코드를 통해 변경의 이유를 파악할 수 있을까?   
1. **인스턴스 변수가 초기화되는 시점**
   + 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
   + 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.
   -> **함께 초기화되는 속성을 기준으로 코드를 분리해야 한다!**
2. **메서드들이 인스턴스 변수를 사용하는 방식**
   + 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.
   + 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.
   -> **속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다!**

### 다형성 패턴
객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라

### 변경보호 패턴(Protected Variations Pattern)
> 변화가 에상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.

## 책임 주도 설계의 대안
설계의 실마리가 풀리지 않거나 적절한 책임과 객체를 선택하는 것에 어려움을 겪고 있다면 최대한 빠르게 목적한 기능을 수행하는 코드를 작성해보는 것도 좋은 방법이다.   
이후 코드에서 드러나는 책임들을 배치하면서 좋은 설계를 얻게 될수도 있다고 한다.

이처럼 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 **리팩터링(Refactoring)**이라고 한다.

