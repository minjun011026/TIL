# 3장
## const와 val
`val`은 변경 불가능한 변수임을 나타내고 이것은 자바의 `final`과 대응된다.   
그렇다면 `const`와 차이가 무엇일까?

`const`는 컴파일 타임 상수이지만 `val`의 변경 불가능함은 런타임에 할당된다.

컴파일 타임 상수는 문자열이나 기본 타입의 래퍼 클래스(Int, Long, Double, Boolean, ...)이며 `getter`를 가질 수 없다.    
또한 컴파일 시점에 사용할 수 있도록 `main`을 포함한 모든 함수의 바깥에서 할당되어야한다.

여기서 유의해야할 점은 `const`는 키워드가 아닌 `private`, `inline`과 같은 변경자로 서로를 대체하는 것이 아닌 반드시 함께 사용해야 한다.

## get()과 set()
코틀린에서는 필드를 직접 선언할 수 없다고 하지만 아래의 코드를 보면 쉽게 이해할 수 없는 말이다. 
```kotlin
class Task(name: String) {
    var priority = 3
}
```
하지만 실제로 priority는 필드를 직접 선언한 것이 아니라, 프로퍼티를 선언한 것이다.   
코틀린에서는 프로퍼티를 선언하면 자동으로 필드(백킹 필드)와 getter, setter가 생성되며, 이를 통해 값에 접근하게 된다.

+ 프로퍼티(property) : 코틀린에서 변수처럼 보이지만 내부적으로 getter와 setter가 있는 클래스 멤버 
```kotlin
var priority = 3
    set(value) {
        field = value
    }

val isLowPriority
    get() = priority < 3
```
위와 같은 방식으로 사용자 정의 생성자(get)와 설정자(set)을 정의할 수 있다.   
여기서 유의해야할 내용은   
`field` 속성을 통해 backing field를 참조하는 경우나    
그냥 property를 선언하 경우에 코틀린은 backing field를 생성한다.   
즉 `isLowPriority`는 backing field가 없다.   
또한 `isLowPriority`는 `val`인데 `get()`의 결과는 바뀔 수 있는게 이상하게 보인다.   
이것은 `isLowPriority`가 저장된 값을 반환하는 것이 아닌 `get()`이 실행될 때마다 계산된 값을 반환하는 것이기 때문이다.   
마치 아래 함수로 값을 반환하는 것과 유사한 원리이다.
```kotlin
fun getLowPriority(): Boolean {
    return priority < 3
}
```

## data class
클래스 정의에 `data`를 추가하면 코틀린은 `equals`, `hashCode`, `toString`, `copy`, `component`와 같은 일련의 함수들을 제공한다.

```kotlin
data class Item(
    val name : String,
    var price : Int,
    var onSale : Boolean = false
)
```
위와 같은 `data class`가 있다면 코틀린 컴파일러는 주 생성자에 선언된 속성을 바탕으로 `equals`와 `hashCode`함수를 생성한다.   
```kotlin
val item1 = Item("Coffee", 4500)
val item2 = Item("Coffee", 4500, false)

val itemSet = setOf(item1, item2)
```
이렇게 `item1`, `item2`를 `itemSet`에 추가해도 실제로는 `item1`과 `item2`는 동등하기 때문에 하나의 Item만 추가된다.
```kotlin
val item3 = item1.copy(price = 5000)
```
위의 방식으로 가격만 5000 변경한 새로운 객체를 생성할 수 있다.   
여기서 유의해야할 점은 **`copy()`는 얕은 복사**로 만약 이러한 `Item`을 원소로 갖는 `data class`혹은 배열 등을 copy한다면 서로 다른 배열에서 서로 같은 객체를 가리키는 상황이 발생한다.

또한 `_componentN_` 이라는 함수가 있다. 각 번호에 대응하는 순서의 속성 값을 리턴한다.
```kotlin
val item1Name = item1.component1()
val item1Price = item1.component2()
```

## Backing Property(지원 속성)
책에서는 Backing Property가 지원 속성으로 작성되어 있어 혼동이 오지만 실제로는 Backing Property라는 표현을 좀더 많이 사용하는 것 같다.
> Backing Property(백킹 프로퍼티)는 실제 값을 저장하는 별도의 private 프로퍼티를 만들고, 공개된 프로퍼티의 getter/setter를 통해 접근하도록 하는 기법입니다. 이는 일반적인 Backing Field(field)와는 다르게, 직접 field를 사용하지 않고 별도의 변수를 활용한다는 차이가 있습니다.

```kotlin
class Customer(val name: String) {
    private var _messages: List<String>? = null

    val messages: List<String>
        get() {
            if (_messages == null) {
                _messages = loadMessages()
            }
            return _messages!!
        }

    private fun loadMessages(): MutableList<String> {
        return mutableListOf(
            "message1",
            "message2",
            "message3"
        ).also { println("load messages") }
    }
}
```
위의 클래스의 인스턴스를 생성한다면 아래와 같다.
```kotlin
val customer = Customer("Teach")
```
이 경우 `_messages`를 초기화하지 않는다.   
이렇게 할 경우의 이점은 사용 전까지 불필요하게 초기화하지 않아 메모리를 절약할 수 있다는 것이다.
```kotlin
println("${customer.messages}") //최초 로딩 load messages 출력
println("${customer.messages}") //이미 로딩되었기에 load messages 출력X
```
즉 제일 처음 접근할 때 비로소 값이 로딩된다.
이것을 지연 로딩(lazy loading)이라 한다.

코틀린은 이것을 보다 쉽게 하기 위해 `lazy` 라는 대리자 함수를 지원한다.
```kotlin
class Customer(val name: String) {
    val messages: List<String> by lazy { loadMessages() }

    private fun loadMessages(): MutableList<String> {
        return mutableListOf(
            "message1",
            "message2",
            "message3"
        ).also { println("load messages") }
    }
}
```

## 연산자 재정의
코틀린은 `+`,`-`와 같은 연산자가 함수로 구성되어 있다.   
만약 어떤 클래스의 연산자를 오버로딩하고 싶다면 `operator` 키워드를 사용하면 된다.
```kotlin
operator fun Item.plus(other:Item) = Item(name, price + other.price, onSale)
val i1 = Item("item1",300)
val i2 = Item("item2",500)
println(i1+i2) // Item("item1", 800, false)
```

## lateinit
속성 초기화시 정보가 충분하지 않을 경우 `lateinit`을 사용해서 지연 초기화할 수 있다.   
```kotlin
class LateItem {
    lateinit var name : String
    
    
    fun initialize(){
        println("name 초기화 여부 : ${::name.isInitialized}")
        name = "Teach"
        println("name 초기화 여부 : ${::name.isInitialized}")
    }
}
//출력결과
//name 초기화 여부 : false
//name 초기화 여부 : true
```
`lateinit`을 사용할 때 유의해야할 점이 있다.
+ nullable하지 않은 타입이어야 한다.
+ 기본 타입에는 사용할 수 없다.(ex. Int)
+ 초기화 전에 접근시 예외를 던진다.
+ `var`과 함께 사용해야 한다.

`lazy`와 달리 객체 밖에서도 초기화가 가능하다.

## equals 재정의
객체 지향 언어에는 객체 동등과 객체 동일 개념이 이다.
자바에서 `==` 연산자는 서로 다른 레퍼런스에 같은 객체가 할당됐는지 즉 객체 동일의 여부를 확인하는데 사용된다.   
반면 Object 클래스 일부인 `equals` 메소드는 객체 동등 여부를 확인한다.   
코틀린에서 `==` 연산자는 기본적으로 `equals` 함수를 호출한다.