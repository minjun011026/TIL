# 4장
## fold
코틀린은 `fold`라는 배열이나 반복 가능한 컬렉션에서 사용할 수 있는 축약 연산을 제공한다.
```kotlin
fun sum(vararg num : Int) = num.fold(0) { acc,n -> acc+n}
```
+ `vararg` : 가변 인자로 함수 `sum`은 여러 개의 `Int` 값을 인자로 받을 수 있다.
+ `acc` : 누적자
+ `n` : 가변인자 num의 각각의 값
+ 괄호 안의 값 : 누적자의 초기값

여기서 `num`의 타입은 `IntArray`다. 실제로 `num::class`를 출력해보면 아래와 같이 나온다.
```
class [I (Kotlin reflection is not available)
```
이것은 `[I` 타입으로 보다 쉽게 `num.javaClass.name` 를 출력하면 아래와 같이 나온다.
```kotlin
[I
```
`[I` 는 JVM에서 int[]로 IntArray이다.

`fold`를 이번에 처음 배워서 피보나치수를 구하는 코드가 신기하다.
```kotlin
fun fibonacciFold(n: Int) =
    (2 until n).fold(1 to 1) { (prev, curr),  ->
        curr to (prev + curr) }.second
```
배열의 원소를 사용하는 것이 아닌 이전 값이라는 속성만을 활용해서 구현한 것으로 `fold`는 굉장히 다양하게 활용할 수 있어 보인다.

## reduce
`reduce`는 `fold`와 거의 같고 단 하나가 다르다. 바로 초기값이 배열의 첫 번째 원소라는 것이다.   
그래서 만약 컬렉션이 비었다면 예외를 던진다. `Array`에서의 실제 내부 구성을 보면 다음과 같다.
```kotlin
public inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {
    if (isEmpty())
        throw UnsupportedOperationException("Empty array can't be reduced.")
    var accumulator: S = this[0]
    for (index in 1..lastIndex) {
        accumulator = operation(accumulator, this[index])
    }
    return accumulator
}
```
그렇다고 `fold`와 완전히 동일하게 사용할 수는 없다.   
예를 들어 각 수에 3을 곱한 값의 합을 구하려 할 때 아래와 같이 코드를 짤 수 있다.
```kotlin
fun sum(vararg num : Int) = num.reduce{ acc,n -> acc+ 3 * n}
sum(1,2,3)
기대값 : 18 
실제값 : 16
```
하지만 이 경우 실제 값은 다르게 나온다.   
그 이유는 첫 번쨰 원소 1은 누적자를 초기화하는데 사용되었기 때문이다.   
이런 경우에는 `fold`가 더 적합하다.   
책에서는 `reduce`의 사용처를 이렇게 말한다.
> 컬렉션의 첫 번째 값으로 누적자를 초기화하고 컬렉션의 다른 값에 추가 연산을 필요로 하지 않는 경우에만 reduce를 사용해라
