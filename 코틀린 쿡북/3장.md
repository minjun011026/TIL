# 3장
## const와 val
`val`은 변경 불가능한 변수임을 나타내고 이것은 자바의 `final`과 대응된다.   
그렇다면 `const`와 차이가 무엇일까?

`const`는 컴파일 타임 상수이지만 `val`의 변경 불가능함은 런타임에 할당된다.

컴파일 타임 상수는 문자열이나 기본 타입의 래퍼 클래스(Int, Long, Double, Boolean, ...)이며 `getter`를 가질 수 없다.    
또한 컴파일 시점에 사용할 수 있도록 `main`을 포함한 모든 함수의 바깥에서 할당되어야한다.

여기서 유의해야할 점은 `const`는 키워드가 아닌 `private`, `inline`과 같은 변경자로 서로를 대체하는 것이 아닌 반드시 함께 사용해야 한다.

## get()과 set()
코틀린에서는 필드를 직접 선언할 수 없다고 하지만 아래의 코드를 보면 쉽게 이해할 수 없는 말이다. 
```kotlin
class Task(name: String) {
    var priority = 3
}
```
하지만 실제로 priority는 필드를 직접 선언한 것이 아니라, 프로퍼티를 선언한 것이다.   
코틀린에서는 프로퍼티를 선언하면 자동으로 필드(백킹 필드)와 getter, setter가 생성되며, 이를 통해 값에 접근하게 된다.

+ 프로퍼티(property) : 코틀린에서 변수처럼 보이지만 내부적으로 getter와 setter가 있는 클래스 멤버 
```kotlin
var priority = 3
    set(value) {
        field = value
    }

val isLowPriority
    get() = priority < 3
```
위와 같은 방식으로 사용자 정의 생성자(get)와 설정자(set)을 정의할 수 있다.   
여기서 유의해야할 내용은   
`field` 속성을 통해 backing field를 참조하는 경우나    
그냥 property를 선언하 경우에 코틀린은 backing field를 생성한다.   
즉 `isLowPriority`는 backing field가 없다.   
또한 `isLowPriority`는 `val`인데 `get()`의 결과는 바뀔 수 있는게 이상하게 보인다.   
이것은 `isLowPriority`가 저장된 값을 반환하는 것이 아닌 `get()`이 실행될 때마다 계산된 값을 반환하는 것이기 때문이다.   
마치 아래 함수로 값을 반환하는 것과 유사한 원리이다.
```kotlin
fun getLowPriority(): Boolean {
    return priority < 3
}
```

## data class
클래스 정의에 `data`를 추가하면 코틀린은 `equals`, `hashCode`, `toString`, `copy`, `component`와 같은 일련의 함수들을 제공한다.

```kotlin
data class Item(
    val name : String,
    var price : Int
)


```