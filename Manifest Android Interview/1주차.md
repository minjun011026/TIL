# Q0 안드로이드랏 무엇인가
+ 모바일 기기를 위해 설계된 오픈소스 운영체제
+ 리눅스 커널 기반

**특징**
1. **오픈 소스 및 커스텀화**
2. **SDK를 이용한 애플리케이션 개발**
3. **풍부한 앱 생태계**
4. **멀티태스킹 및 리소스 관리**
   + 여러 앱 동시 실행 가능, 관리형 메모리 시스템과 효율적인 가비지 컬렉션으로 성능 최적화 
     > 관리형 메모리 시스템 : 개발자가 메모리를 직접 할당하고 해제하는 대신 ART가 자동으로 처리해주는 시스템            
      ART의 동시성 GC: 앱의 메인 스레드가 실행되는 동안, 별도의 백그라운드 스레드에서 동시에 가비지를 찾고 표시하는 작업을 대부분 수행 앱을 잠시 멈추는 시간은 청소 마무리 단계에서 아주 짧은 순간(몇 ms)으로 최소화   
세대별 GC : ART는 세대 기반 GC로 확장, 생성된 지 얼마 안 된 객체를 수집할 수 있으며 이러한 객체는 별다른 노력 없이도 상당히 빨리 도달할 수 없는 상태가 됨

5. **다양한 하드웨어 지원**

참고 : https://source.android.com/docs/core/runtime/gc-debug?hl=ko

**안드로이드 아키텍처**   
**앱** : 최상위 계층, 시스템 앱(연락처, 설정 등)과 안드로이드 SDK를 사용하여 생성된 서드파티 앱을 포함한 모든 유저 기반의 앱      
|    
**안드로이드 프레임워크** : ActivityManager, NotificationManager, ContentProviders 등을 포함하는 앱 개발을 위한 고수준 서비스와 API를 제공   
|   
**네이티브 라이브러리** : 네이티브 C/C++ 라이브러리 모음, 그래픽 렌더링 관리, 데이터베이스 작업, 웹 콘텐츠 표시 등의 기능 지원   
|   
**안드로이드 런타임(ART)** : Kotlin이나 Java에서 컴파일된 바이트코드를 사용하여 앱 실행, 최적화된 성능을 위해 Ahead-of-Time(AOT) 및 Just-in-Time(JIT) 컴파일 지원, 핵심 라이브러리는 데이터 구조, 파일 조작, 스레딩 등을 위한 필수 API를 제공하여 앱 개발을 위한 포괄적인 환경 제공    
|   
**Hardware Abstraction Layer(HAL)/HIDL** : 안드로이드의 Java API 프레임워크를 기기 하드웨어에 연결하는 표준 인터페이스 제공, 라이브러리 모듈로 구성, 각 모듈은 카메라, 블루투스 같은 특정 하드웨어 구성 요소에 맞춰져 있음. 프레임워크 API가 하드웨어 접근 요청시 안드로이드 시스템은 해당 HAl 모듈을 동적으로 로드하여 처리.   
|   
**Linux Kernel** : 안드로이드 운영 체제의 기반 형성, 하드웨어 추상화 처리, 소프트웨어와 하드웨어 간의 원활한 상호 작용 보장, 메모리 및 프로세스 관리, 보안 강화, Wifi와 같은 하드웨어 구성 요소의 장치 드라이버 관리 등을 책임진다.

참고
+ HIDL : HAL 인터페이스 정의 언어,  HAL과 HAL 사용자 간의 인터페이스를 지정하는 인터페이스 설명 언어(IDL)

## 실전 질문
Q) 안드로이드 플랫폼 아키텍처는 Linux Kernel, Android Runtime(ART), Hardware Abstraction Layer(HAL) 등 여러 계층으로 구성됩니다. 이 구성요소들이 애플리케이션 실행과 하드웨어와의 상호 작용을 위해 어떻게 작동하는지 설명해주세요.      
A)    
**애플리케이션 실행 과정**   
1. 앱 실행시 안드로이드 프레임워크의 ActivityManager가 요청을 받아 앱 실행 준비   
2. 안드로이드 프레임워크는 Linux Kernel한테 프로세스 생성 요청, 커널은 고유한 메모리 공간과 CPU 할당   
3. 프로세스가 준비되면 안드로이드 프레임워크는 ART에게 dex파일 로드 지시   
4. ART는 AOT/JIT 컴파일을 통해 바이트 코드를 기계어로 번역
5. UI를 그릴 때 안드로이드 프레임워크는 네이티브 라이브러리에 속하는 Skia와 같은 라이브러리를 호출하여 화면 렌더링
6. 앱이 실행되는 동안 Kernel이 메모리 관리, 스레드 스케줄링, 보안 등 시스템 핵심 기반 담당

**하드웨어 상호 작용 과정**
1. 앱이 안드로이드 프레임워가 제공하는 고수준 API 호출(CameraManager 등)
2. 안드로이드 프레임워크는 "카메라를 켜라"라는 요청은 알지만 "삼성전자의 카메라 센서"를 켜는 구체적인 방법은 모르기에 이 요청을 HAL에게 전달
3. HAL은 안드로이드 시스템이 제조사(삼성 등)로부터 제공받은 특정 카메라 HAL 모듈을 동적으로 로드, 이 모듈은 프레임워크의 표준 요청을 실제 하드웨어가 이해할 수 있는 저수준 언어로 번역
4. HAl 모듈은 하드웨어를 직접 제어하는 것이 아닌 Linux Kernel에 포함된 해당 하드웨어의 장치 드라이버와 통신
5. Linux Kernel의 카메라 드라이버가 HAL로부터 받은 명령을 최종적으로 처리. 물리적인 카메라 하드웨어에 신호를 보내 카메라를 킴. 이후 카메라로부터 들어오는 데이터는 역순으로 전달


# Q1 인텐트(Intent)란 무엇인가요?
Intent는 수행될 작업에 대한 추상적인 설명   
Activity, Service, BroadcastReceiver가 통신할 수 있도록 하는 메시징 개체 역할을 수행   
일반적으로 Activity를 시작하거나 브로드캐스트를 보내거나 Service를 시작하는데 사용   
컴포넌트 간에 데이터 전달이 가능해 안드로이드 시스템의 근본이 되는 요소   

Intent는 명시적, 암시적 두 유형이 존재   
1. Explicit Intent(명시적 인텐트)
 + 정의 : 명시적 Intent는 호출할 컴포넌트(Activity/Service)를 직접 이름으로 지정하여 정확히 명시
 + 사용 사레 : 대상 컴포넌트를 알고 있을 때 사용(ex. 앱 내의 특정 Activity 시작)
 + 시나리오 : 동일한 앱 내에서 한 Activity 에서 다른 Activity로 전환하는 경우 사용
```kotlin
val intent = Intent(this, TargetActivity::class.java)
startActivity(intent)
```
2. Implicit Intent(암시적 인텐트)
 + 정의 : 암시적 Intent는 특정 컴포넌트를 지정하지 않고 수행할 일반적인 작업을 선언, 시스템은 action, category, data를 기반으로 어떤 컴포넌트가 Intent를 처리할 수 있는지 결정
 + 사용 사례 : 다른 앱이나 시스템 컴포넌트가 처리할 수 있는 작업을 수행하려 할 때 유용(ex. URL 열기, 콘텐츠 공유)
 + 시나리오 : 브라우저에서 웹 페이지를 열거나 다른 앱과 콘텐츠를 공유하는 경우, 시스템이 Intent를 처리할 앱 결정
```kotlin
val intent = Intent(Intent.ACTION_VIEW)
intent.data = Uri.parse("https://www.example.com")
startActivity(intent)
```

참고   
암시적 Intent의 action, category, data란   
action : 수행될 일반적인 동작(ex.`ACTION_VIEW` - 보기, `ACTION_EDI`T - 편집, `ACTION_MAIN` - 메인으로 실행 등)   
category : 실행할 액션에 대한 부가적인 정보(ex.`CATEGORY_LAUNCHER`는 해당 인텐트가 런처(홈 화면)에 최상위 애플리케이션으로 표시되어야 함을 의미)   
data : action이 작업을 수행할 데이터

## 실전 질문
Q) 명시적 인텐트와 암시적 인텐트의 차이점은 무엇이며, 각각 어떤 시나리오에서 사용해야 하나요?   
A) 호출할 대상을 명확하게 지정하는지 여부, 명시적 인엔트는 명확한 대상을 지정, 암시적 인텐트는 action만 지정하고 실행은 시스템이 결정한다.
명시적 인텐트는 Activity 이동, 앱 내부 Service 시작, 암시적 인텐트는 웹 브라우저 열기 등 앱에서 지원하지 않는 기능을 다른 앱에 위임할 때 사용   

Q) 안드로이드 시스템은 암시적 인텐트를 처리할 앱을 어떻게 결정하며, 적합한 애플리케이션을 찾지 못하면 어떻게 되나요?   
A) 인텐트의 콘텐츠를 기기에 있는 다른 앱들의 Manifest 파일에 선언된 인텐트 필터를 확인하며 시작할 적절한 구성요소를 찾는다. 일치시 시스템은 해당 구성요소를 시작하고 Intent객체를 전달한다. 만약 호환되는 인텐트 필터가 여러 개라면 사용자가 선택할 수 있도록 대화 상자를 띄운다.   
못 찾으면 ActivityNotFoundException라는 예외를 던지고 앱 강제 종료

## Pro Tips for Mastery: 인텐트 필터란 무엇인가요?
Intent Filter는 앱 컴포넌트가 링크 열기나 브로드캐스트 처리와 같은 특정 Intent에 어떻게 응답할 수 있는가를 정의한다.   
이는 Activity, Service, BroadcastReceiver가 처리할 수 있는 Intent 유형을 선언하는 필터 역할을 수행하며 AndroidManifest.xml에 명시됨   
각 intent filter는 들어오는 Intent와 정확히 일치시키기 위해 action, category, data의 유형을 포함할 수 있음.   
intent filter를 적절하게 정의하면 앱이 다른 앱 및 시스템 컴포넌트와 원활하게 상호 작용하여 기능을 향상시킬 수 있음.

# Q2 PendingIntent의 목적은 무엇인가요?
PendingIntent는 다른 애플리케이션이나 시스템 컴포넌트가 애플리케이션을 대신하여 미리 정의된 Intent를 나중에 실행할 수 있는 권한을 부여하는 또 다른 종류의 Intent   
알림/서비스와의 상호작용 등 앱의 수명 주기를 벗어나 트리거되어야 하는 작업에 유용함 

**특징**
+ 일반 Intent의 wrapper 역할을 하여 앱의 생명주기를 넘어서 지속될 수 있도록 한다.
+ 앱과 동일한 권한으로 다른 앱이나 시스템 서비스에 Intent 실행을 위임한다.
+ Activity, Service, BroadcastReceiver를 위해 생성될 수 있다.
+ Activity, Service를 시작하거나 Broadcast를 보내는 형태로 주로 사용된다.   
대표적인 플래그는 다음과 같다.
+ FLAG_UPDATE_CURRENT : 기존 PendingIntent를 새 데이터로 업데이트
+ FLAG_CANCEL_CURRENT : 새 PendingIntent를 만들기 전에 기존 PendingIntent 취소
+ FLAG_IMMUTABLE : PendingIntent를 변경 불가능하게 만들어 수신자가 수정하는 것을 방지
+ FLAG_ONE_SHOT : PendingIntent가 한 번만 사용될 수 있도록 보장      
사용 사례
notification(notification 탭시 activity 열기), alarm(작업 예약), service(백그라운드 작업)   

악의적인 앱이 기본 Intent를 수정하는 것을 방지하기 위해 FLAG_IMMUTABLE 설정해줘야함.   

## 실전 질문
Q) PendingIntent란 무엇이며 일반 Intent와 어떻게 다른가요? PendingIntent 사용이 필요한 시나리오를 제시해 줄 수 있나요?
A) PendingIntent는 일반 Intent를 wrapping 하여 다른 앱이나 시스템 컴포넌트에게 사전에 정의된 Intent의 실행을 대신 위임한다.   
알람을 터치시 앱이 실행되도록 하는 상황에서 사용

# Q3 Serializable과 Parcelable의 차이점은 무엇인가요?
Serializable
+ **Java 표준 인터페이스** : 객체르 바이트스트림으로 변환하여 Activity간에 전달하거나 디스크에 쓸 수 있도록 함
+ **리플렉션 기반**
+ 리플렉션이 느린 프로세스이므로 Parcelable보다 느림, 직렬화 중 많은 임시 객체 생성으로 메모리 오버헤드를 증가시킴
+ 성능이 중요하지 않거나 안드로이드 특정 코드가 아닌 코드베이스 다룰 때 유용   
Parcelable
+ **안드로이드 기반 인터페이스**
+ 안드로이드에 최적화되어 있고 리플렉션에 의존하지 않아 Serializable보다 빠름, 많은 임시 객체 생성을 피하여 가비지 컬렉션 최소화
+ 성능이 중요한 안드로이드 데이터 전달, IPC, Activity, Service간 데이터 전달에 선호됨

## 실전 질문
Q) 안드로이드에서 Serializable과 Parcelable의 차이점은 무엇이며, 일반적으로 컴포넌트 간 데이터 전달에 Parcelable이 선호되는 이유는 무엇인가요?   
A) Serializable은 자바 기반 인터페이스이고 Parcelable은 안드로이드 기반 인터페이스이다. 또한 Serializable은 Parcelable과 달리 리플렉션 기반으로 런타임에 처리되어 더 느리다.   
그러나 Parcelable은 안드로이드 기반 인터페이스로 서버가 Java 혹은 다른 언어 기반으로 구성되어있을 경우에는 Serializable을 사용해야 한다.   
컴포넌트간 데이터 전달에는 안드로이드 기반 인터페이스로 안드로이드에 최적화되있다는 점과 리플렉션을 사용하지 않는다는 점 그리고 가비지 생성이 더 적다는 점에서 성능적으로 Serializable보다 뛰어나 Parcelable이 선호된다.

Parcel은 안드로이드에서 컴포넌트간 고성능 IPC를 가능하게 하는 컨테이너 클래스로   
데이터를 Marshalling과 UnMarshalling하여 전달하는데 이때 바이너리 데이터로 변환한다.   
지금은 Serialization도 자체적인 코드 생성을 해주는 것으로 알고 있어 리플렉션의 단점을 극복한 것으로 알고 있는데 그럼에도 Serializable은 JSON문자열로 변환하여 String타입이라 임시 객체 생성 문제는 극복하지 못하였다.   

참고   
IBinder : IPC를 위한 핵심 안드로이드 인터페이스, 클라이언트와 서비스같은 다른 컴포넌트 간의 저수준 통신 브리지 역할을 하여 원격으로 데이터를 교환하거나 메서드를 호출하여 상호작용할수 있도록 한다.    

# Q4 Context란 무엇이며 어떤 유형의 Context가 있나요?
Context는 애플리케이션의 환경 또는 상태를 나타내며 애플리케이션별 리소스 및 클래스에 대한 접근을 제공한다.   
앱과 안드로이드 시스템 간의 브릿지 역할을 하며 컴포넌트가 리소스, 데이터베이스, 시스템 서비스 등에 접근할 있도록 한다.   
Activity 실행, assets 접근, 레이아웃 인플레이션과 같은 작업에 필수

Context의 유형
+ **Application Context**: 앱의 라이프사이클과 연결, 전역적이고 오래 지속되는 context 필요시 사용  
  + 앱 전체 리소스 접근
  + 앱 생명주기 동안 지속되어야 하는 BroadcastReceiver 등록
  + 앱 생명주기 동안 유지되는 라이브러리나 컴포넌트 초기화
+ **Activity Context** : Activity의 생명주기와 연결, Activity 특정 리소스 접근, 다른 Activity 시작, 레이아웃 인플레이션에 사용
  + UI 컴포넌트 생성/업데이트
  + 다른 Activity 실행
  + 현재 Activity 범위에 있는 리소스나 테마 접근
+ **Service Context** : Service의 생명주기와 연결, 네트워크 작업 수행이나 백그라운드 작업에 사용, Service가 필요한 시스템 수준 서비스에 대한 접근 제공
+ **Broadcast Context** : BroadcastReceiver가 호출될 때 제공, 수명이 짧음, 주로 특정 브로드캐스트 응답할 때 사용 -> Broadcast Context로 장기적인 task 수행 X

## 실전 질문
Q) 안드로이드 애플리케이션에서 올바른 유형의 Context를 사용하는 것이 왜 중요하며, Activity Context에 대해 오랜 참조를 유지하는 것은 잠재적으로 어떤 문제를 발생시킬 수 있나요?
A) 
1. 필요한 기능이 다름 : 예를 들어 Application Context에서 다이얼로그를 띄우려하면 UI를 띄울 윈도우가 없어 WindowManager$BadTokenException 발생한다.
2. 메모리 누수 방지 : 만약 activity context를 싱글톤 객체가 참조하고 있다면 이후에 Activity가 onDestroy 될때 정상적인 상황에서는 GC가 메모리를 회수해야하지만 싱글톤이 Activity의 context를 잡고 있어 GC가 아직 이 Activity가 사용중이라고 판단하여 메모리에서 해제되지 않는다.

Context 사용시 주의할 점    
+ context는 메인 스레드용으로 설계되어 백그라운드 스레드에서 사용시 크래시나 스레딩 문제 발생 가능   
-> 백그라운드 작업중 UI 관련 context 리소스와 상호작용이 필요하다면 메인 스레도로 전환해야 한다.

### ContextWrapper란 무엇인가요?   
ContextWrapper는 Context를 상속받고 있는 클래스로 Context 객체를 감싸서 래핑된 Context에 대한 호출을 위임하는 기능을 제공한다.   
원본 Context의 동작을 수정하거나 확장하기 위한 중간 계층 역할 수행   
ContextWrapper를 사용하면 Context와 직접적인 소통을 하지 않고도 특정 기능 커스텀 가능   

사용 사례 
+ Custom Context, 동적 리소스 처리, 의존성 주입  
이점
+ 재사용성 : 커스텀 로직을 래퍼 클래스에 캡슐화하고 여러 컴포넌트에서 재사용 가능
+ 캡슐화 : 원본 Context 구현을 변경하지 않고 동작 개선 및 필요에 맞게 재정의 
+ 호환성 : 이미 존재하던 Context 객체와 원활하게 작동

### Activity 에서 this와 baseContext 인스턴스의 차이점은 무엇인가요?
**Activity 에서의 this**   
+ Activity 클래스의 현재 인스턴스 참조
+ Activity는 ContextWrapper의 하위 클래스로 this는 생명 주기 관리 및 UI와의 상호작용과 같은 추가 기능을 포함하여 Activity와 상호 작용이 가능한 API 호출 가능
+ Activity에서 this 호출시 현재 Context를 참조하므로 해당 Activity에서 제공하는 고유한 메소드 호출 가능

**Activity 에서의 baseContext**
+ Activity가 구축되는 기반 또는 기본 Context를 나타내며, 이는 Activity가 상속하고 있는 ContextWrapper의 일부
+ Context 메서드에 대한 핵심 구현을 제공하는 ContextImpl 인스턴스
+ 커스텀 ContextWrapper을 작업하거나 ContextWrapper가 갖고 있는 원본 Context를 참조할 때 사용

**this와 baseContext의 주요 차이점**
+ **범위(Scope)** : this는 현재 Activity의 인스턴스와 그 생명주기를 나타내는 반면, baseContext는 Activity가 구축된 저수준의 Context 참조
+ **사용법** : this는 Activity 생명주기, UI관련 작업에 사용, baseContext는 커스텀 ContextWrapper 구현할 때 Context의 핵심 구현체와 상호 작용시 사용

참고   
레이아웃 인플레이션 : XML 레이아웃 파일을'파싱하여 실제 안드로이드 View 객체(예: TextView, Button)로 만들어 메모리에 로드하는 과정, compose에서는 composition   

# Q5. Application 클래스란 무엇인가요?
+ Application 클래스는 전역 애플리케이션 상태와 생명주기를 유지하기 위한 역할을 수행   
+ 다른 컴포넌트보다 가장 먼저 초기화되는 앱의 프로세스 진입점 역할   
+ 앱의 전체 생명주기 사용 가능한 Context 제공

**목적**   
전역 상태를 유지하고 애플리케이션 전체 초기화를 수행하도록 설계되었다.   
개발자는 종종 이 클래스를 상속받아 의존성을 설정하고, 라이브러리를 구성하기도 하고, Activity와 Service 전반에 걸쳐 지속되어야 하는 리소스를 초기화 한다.   
기본적으로 모든 안드로이드 애플리케이션은 AndroidManifest.xml에 커스텀 클래스를 지정하지 않는 한 Application 클래스의 기본 구현체를 사용한다.   

**주요 메서드**   
+ `onCreate` : 앱 프로세스 생성시 호출, 애플리케이션 전체 의존성을 초기화하는 곳, 애플리케이션 생명주기 동안 단 한번만 호출됨
+ `onTerminate` : 애플리케이션이 종료될 때 호출, 안드로이드가 호출을 보장하지 않으므로 실제 기기의 프로덕션 환경에서는 호출 안됨
+ `onLowMemory` / `onTrimMemory` : 시스템이 메모리 부족 상태를 감지할 때 트리거된다, `onLowMemory는` 이전 API 레벨에서 사용되며 `onTrimMemory`는 앱의 현재 메모리 상태에 따라 더 세분화된 제어를 제공한다.

**사용 방법**   
Application 클래스를 상속받고 AndroidManifest.xml 파일의 `<application>` 태그에 수동으로 지정해야 한다.

**사용 사례**   
+ 전역 리소스 관리
+ 컴포넌트 초기화
+ 의존성 주입

**주의사항**   
1. 초기 앱 실행 지연을 방지하기 위해 `onCreate`에 무거운 태스크를 실행하지 않는 것이 좋다.
2. 관련 없는 로직을 `Application` 클래스에 때려박으면 안된다. 전역 초기화 및 리소스 관리에만 집중하는 것이 좋다.
3. 앱 전반에 걸쳐서 사용되야 하는 공유 리소스에 대해서는 스레드 안정성을 보장해야 한다.

## 실전 질문
Q) Application 클래스의 목적은 무엇이고, 생명주기 및 리소스 관리 측면에서 Activity 와는 어떻게 다른가요?   
A) 전역 리소스와 의존성 주입 관리 및 앱 전체 초기화   
한 화면만을 전담하고 여러 개를 생성할 수 있는 Activity와 다르게 Application은 싱글톤이며 앱 전체 생명 주기 기간과 전역 리소스 관리를 담당한다.

참고   
`onTerminate`는 실제 환경에서 절대 호출되지 않는다. 공식문서에 다음과 같이 나와있다.
> It will never be called on a production Android device, where processes are removed by simply killing them

즉 그냥 kill을 해버리기 때문에 프로덕션 환경에서는 절대 호출되지 않는다.


# Q6 AndroidManifest 파일의 목적은 무엇인가요?
AndroidManifest.xml 파일은 안드로이드 운영체제에 애플리케이션에 대한 필수 정보를 정의하는 안드로이드 프로젝트에서 매우 중요한 구성 파일   
애플리케이션과 OS 간의 브릿지 역할을 수행하며 컴포넌트, 권한, 하드웨어 및 소프트웨어 기능 등을 정의한다.

**주요기능**
1. 애플리케이션 컴포넌트 선언
2. 권한
3. 하드웨어 및 소프트웨어 요구 사항
4. 앱 메타 정보 : 패키지 이름, 버전, 최소 및 대상 API 레벨 등의 정보 제공
5. 인텐트 필터
6. App Configuration/Settings : 메인 런처 Activity 정의, 백업 동작 구성 등을 포함, 앱의 동작 방식과 표시 방식 제어하는데 도움

## 실전 질문
Q) AndroidManifest의 인텐트 필터는 앱 상호 작용을 어떻게 가능하게 하고, 액티비티 클래스가 AndroidManifest에 등록되어있지 않으면 어떻게 되나요?   
A) 다른 애플리케이션이 보낸 Implicit Intent가 앱들의 AndroidManifest를 확인하며 해당 앱의 인텐트 필터가 자신을 수행할 수 있는지 비교한다. 만약 일치한다면 시스템이 옵션으로 보여주거나 즉시 실행하게 된다.
어떤 Activity 클래스를 잘 정의해놓았더라도 AndroidManifest에 등록되어있지 않다면 `startActivity`로 해당 Activity를 시작하려고 할때 시스템은 명단에 없는 Activity이기에 없다고 판단하여 예외가 발생한다.

# Q7 Activity 생명주기를 설명해주세요
1. `onCreate` : Activity가 생성될 때 호출되는 첫 번째 메소드, Activity 초기화, UI 컴포넌트 설정, 저장된 인스턴스 상태 복원을 수행한다. Activity가 소멸되고 재생성되지 않는 한 Activity의 생명주기 동안 단 1번만 호출된다.
2. `onStart` : Activity가 사용자에게 보이지만 아직 상호작용할 수 없는 상태, `onCreate` 이후 `onResume` 이전에 호출
3. `onRestart` : Activity가 중지(onStop)되었다가 다시 시작될 때, `onStart` 전에 호출
4. `onResume` : Activity가 포그라운드에 있으며 사용자와 상호작용 가능, 일시 중지된 UI 업데이트, 애니메이션 또는 입력 리스너를 재개하는 곳
5. `onPause` : 다른 Activity에 의해 Activity가 **부분적으로** 가려질 때 호출, 여전히 보이지만 포커스 중인 상태가 아님, 애니메이션, 센서 업데이트 또는 데이터 저장과 같은 작업을 일시 중지하는 데 사용
6. `onStop` : Activity가 더이상 사용자에게 안 보일때 호출, Activity가 중지된 동안 필요하지 않은 리소스 해제해야 한다.
7. `onDestroy` : Activity가 완전히 소멸되고 메모리에서 제거되기 전에 호출, 남아 있는 모든 리소스를 해제하기 위한 최종 메소드

## 실전 질문
Q) onPause()와 onStop()의 차이점은 무엇인지 설명하고, 리소스 점유율이 높은 작업을 처리하는 경우 해당 메서드들을 어떤 시나리오에서 사용해야 하나요?   
A) onStop과 다르게 onPause는 Activity가 사용자에게 보인다. 리소스 점유율이 높은 작업을 처리할 때 onPause는 작업을 잠시 중단하는 작업, 예를 들어 카메라/마이크 해제같이 즉시 중지해야 하는 작업에서 사용하고 onStop은 브로드캐스트 리시버 해제와 같이 리소스를 해제해야 하는 작업에서 사용해야 한다.

Activity A 시작한 다음 Activity B 시작하도 다시 A로 돌아올 때 생명주기 변화   
AonCreate() -> AonStart() -> AonResume() -> AonPause() -> BonCreate() -> BonStart() -> BonResume() -> AonStop() -> BonPause() -> AonRestart() -> AonStart() -> AonResume() -> BonStop() -> BonDestroy()

### Activity의 Lifecycle 인스턴스란 무엇인가요?
모든 Activity는 Lifecycle 인스턴스를 가지고 있고 이는 Activity의 생명주기 이벤트를 관찰하고 이에 반응하는 방법을 제공한다.   
생명주기 인식, 관심사 분리, Jetpack 라이브러리와의 호환성이라는 이점이 존재한다.

# Q8 Fragment 생명주기를 설명해주세요
각 Fragment 인스턴스는 연결된 부모 Activity의 생명주기와 별도로 자체적인 생명주기를 갖는다.   
1. `onAttach` : Fragment가 부모 Activity와 연결될 때 호출되는 첫 번째 콜백, 이제 Fragment가 연결되었으며 Activity 컨텍스트와 상호작용 가능
2. `onCreate` : Fragment를 초기화하기 위해 호출, 이 시점에서 Fragment는 생성되었지만 UI는 아직 생성되지 않음, 필수 컴포넌트 초기화/저장 상태 복원
3. `onCreateView` : Fragment의 UI가 처음으로 그려질 때 호출, Fragment 레이아웃의 루트 뷰 반환, LayoutInflater를 사용하여 Fragment의 레이아웃을 인플레이션하는 곳
4. `onViewStateRestored` : Fragment의 뷰 계층이 생성되고 저장된 상태가 뷰에 복원된 후 호출
5. `onViewCreated` : Fragment의 뷰가 생성된 후 호출, UI 컴포넌트와 사용자 상호작용처리에 필요한 로직 설정하는데 사용
6. `onStart` : Fragment가 사용자에게 보이게 됨, 활성 상태지만 아직 포그라운드는 아님
7. `onResume` : 완전히 활성상태, 포그라운드에서 실행 중으로 사용자와 상호작용 가능, 완전히 UI가 화면에 표시되고 상호작용 가능할 때 호출됨
8. `onPause` : Fragment가 더이상 포그라운드에 있지 않지만 여전히 화면에 보일 때, 포커스 잃기 직전, 포그라운드에 없을 때 지속하면 안되는 작업 일시 중지해아함
9. `onStop` : Fragment가 더이상 안보임, Fragment가 화면 밖에 있는 동안 지속해야할 필요가 없는 작업 중지하는 곳,
10. `onSaveInstanceState` : Fragment가 소멸되기 전 UI 관련 상태 데이터 저장하여 나중에 복원할 수 있도록 호출됨
11. `onDestroyView` : Fragment의 뷰 계층이 제거될 때 호출, 메모리 누수 방지하고자 어댑터를 지우거나 참조를 null로 만드는 등 뷰와 관련된 리소스를 정리해야 함
12. `onDestroy` : Fragment 자체가 소멸될 때 호출, 이 시점에서 모든 리소스 정리해야하지만 아직은 부모 Activity와 연결된 상태
13. `onDetch` : Fragment가 부모 Activity 에서 분리됨, 마지막 콜백으로 생명주기 완료

## 실전 질문
Q) onCreateView()와 onDestroyView()의 목적은 무엇이며, 해당 메서드에서 뷰 관련 리소스를 올바르게 처리하는 것이 왜 중요한가요?   
A) onCreateView는 뷰를 반환하는 것 onDestroyView는 뷰를 제거하는 것,   
Fragment와 뷰의 생명주기가 다르기 때문에 예를 들어 현재 보이지 않는 Fragment의 뷰라 할지라도 계속 값을 참조하고 있어 메모리 누수가 발생할 수 있기 때문이다.

**fragmentManager**   
+ FragmentActivity 또는 Fragment와 연결되어 있으며 Activity 수준에서 Fragment를 관리하는 역할
+ 부모 Activity에 직접 연결된 Fragment를 추가하너가 교체/제거하는 동작을 포함
+ Activity에서 supportFragmentManager를 호출하면 FragmentActivity에서 관리하는 fragmentManager에 접근가능
+ fragmentManager에 의해 관리되는 Fragment는 <u>형제관계이며 동일한 계층 수준</u>에서 동작

**childFragmentManager**   
+ childFragmentManager는 하나의 Fragment에 속하며 해당 Fragment의 자식 Fragment를 관리한다.
+ 이를 통해 Fragment가 다른 Fragment를 호스팅하여 중첩된 Fragment 구조를 만들 수 있음
+ childFragmentManager를 사용하면 부모 Fragment의 생명주기 내에서 Fragment를 정의
+ Fragment가 Activity의 Fragment 생명주기와 독립적이며 Fragment를 중첩해서 사용해야 하는 경우 Fragment 내에서 UI와 로직을 캡슐화할 때 유용하다.
+ 부모 Fragment 소멸시 자식 Fragment 소멸

### Fragment의 viewLifecycleOwner
Fragment는 호스팅 Activity에 연결되어 자체적인 생명주기를 갖지만 Fragment의 뷰 계층(View hierarchy)은 이와 별도의 생명주기를 갖는다.   

**정의**
+ viewLifecycleOwner는 Fragment의 뷰 계층과 관련된 LifecycleOwner
+ onCreateView가 호출될 때 시작되고 onDestroyView가 호출될 때 끝나는 Fragment 뷰의 생명주기를 나타냄

**용도**
+ UI 관련 데이터나 리소스를 Fragment의 생명주기가 아닌 Fragment 뷰 계층 생명주기에 바인딩하여 잠재적인 메모리 누수와 같은 문제 방지
+ 데이터나 생명주기 이벤트 관찰을 위해 Fragment 생명주기 사용시 뷰 소멸 이후에도 뷰에 접근할 수 있는 위험성이 존재하는데 이것을 방지하고 뷰가 소멸할 때 업데이트를 안전하게 중지 가능할 수 있다.




참고   
`onCreateView`에서 복원된 값으로 그리는 게 아님, `onCreateView`는 뷰를 반환하고 `onViewStateRestored` 직전에 시스템이 자동으로 복원함 `onViewStateRestored`는 복원이 완료되었다는 신호