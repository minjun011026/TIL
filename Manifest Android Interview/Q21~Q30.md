# Q21 SparseArray를 사용하면 어떤 이점이 있나요?
SparseArray는 HashMap과 유사하게 정수 키를 객체 값에 매핑하는 안드로이드에 최적화된 데이터 구조이다.   
정수인 키를 함께 사용하도록 최적화되어 있어 정수 기반 키를 사용할 때 일반적인 Java/Kotlin의 Map이나 HashMap보다 메모리 관리측면에서 효율이 좋고 상황에 따라 성능이 더 좋다.   

| **특징**
1. **메모리 효율성** : 키-값 매핑을 위해 HashTable을 사용하는 HashMap과 달리 SparseArray는 오토박싱(Int -> Integer 변환)을 피하고 Entry 객체와 같은 추가 데이터 구조에 의존하지 않아 훨씬 적은 메모리 소비
2. **성능** : 매우 큰 데이터 셋의 경우 HashMap만큼 빠르지는 않지만 SparseArray는 메모리 최적화 덕분에 중간 크기의 데이터 셋에서 더 나은 성능을 제공
3. **Null 키 값 사용 불가** : SparseArray는 키 값으로 기본 정수를 사용하므로 키 값에 null을 허용하지 않음

| **이점**
1. **오토박싱 방지** : HashMap<Integer, Object>에서는 키가 Integer 객체로 저장되어 박싱/언박싱 작업으로 인한 오버헤드 발생, SparseArray는 Int 키로 직접 이동하여 메모리와 계산 작업 절약
2. **메모리 절약** : SparseArray는 키와 값을 저장하기 위해 내부적으로 기본 배열을 사용, Entry와 같은 여러 객체를 생성하는 HashMap 구현에 비해 메모리 차지 공간을 줄인다.
3. **컴팩트한 데이터 저장에 효율적** : 적은 수의 키-값 쌍이 있는 밀도가 낮은(sparse) 데이터 셋이나 키가 넓은 정수 범위에 걸쳐 드문드문 분포된 데이터 셋에 적합하다.
   + 컴팩트한 데이터가 아니라 데이터를 컴팩트하게 저장하는 것 ex) 1번째와 1000000번째 인덱스 사용하려면 일반 배열은 1000001 크기 필요 하지만 SparseArray는 [1, 1000000]와 같이 저장됨 
4. **안드로이드 특화** : 제한된 리소스 시나리오를 처리하기 위해 안드로이드에 특화된 구조로 설께되어 안드로이드 UI 컴포넌트에서 ViewId를 객체에 매핑하는 등의 시나리오에 효과적

| **SparseArray의 한계**
1. 성능 Tradeoff : SparseArray의 요소 접근은 키 **조회를 위해 이진 탐색을 사용**하기 때문에 매우 큰 데이터 셋의 경우 HashMap보다 느리다.
2. **정수 키만 사용 가능** : 정수 키로 제한되어 다른 유형의 키가 필요한 사용 사례에는 적합하지 않다.

## 실전 질문
Q) HashMap 대신 SparseArray를 사용하는 것이 어떤 시나리오에서 더 효율적이며, 성능 및 사용성 측면에서 트레이드오프는 무엇인가요?   
A) 메모리 효율이 속도보다 더 중요한 상황에서 데이터 개수가 수백개 수준으로 그리 많지 않을 때 SparseArray를 사용하는 것이 더 효율적이다.   
메모리 효율이 좋지만 데이터 검색에 이진 탐색을 사용하여 데이터가 매우 클 경우 HashMap에 비해 성능이 떨어진다. 또한 사용성 측면에서 안드로이드에 특화되어 있는만큼 범용성이 좋지 않다.

# Q22 런타임 권한을 어떻게 처리하나요?
안드로이드 6.0(API레벨 23)부터 앱은 설치 시 자동으로 권한을 획득하는 대신 런타임에 위험 권한을 명시적으로 요청해야 한다.   

| **권환 확인**   
+ `ContextCompat.checkSelfPermission()`으로 권한이 이미 부여되었는지 확인

| **권한 요청**    
+ `ActivityResultLauncher` 사용

| **권한 요청 근거 제공하기**   
+ `shouldShowRequestPermissionRationale()`로 권한 요청하기 전 권한이 필요한 근거를 표시하여 사용자 경험 개선 및 권한 획득 가능성을 높인다.
+ 처음 설치하고 권한 요청을 한 번도 안한 초기에도 false 반환함

| **권한 거부 처리하기**    
사용자가 권한을 여러 번 거절하면 안드로이드는 이를 영구적인 거부로 받아들여 앱이 해당 권한을 다시는 요청할 수 없게 된다.   
이 경우 앱은 사용자에게 기능이 제한된 이유에 대해 고지하고 필요한 경우 시스템 설정으로 안내하여 직접 해당 권한을 처리할 수 있도록 해야 한다.   

`shouldShowRequestPermissionRationale()`는 권한 요청이 한번도 이루어지지 않더라도 false를 반환하기에 권한 요청이 이루어진 적 있는지 확인이 필요하다.   

| **위치 권한 처리하기**    
위치 권한은 포그라운드와 백그라운드 접근으로 분류된다.   
포그라운드 위치 접근에는 ACCESS_FINE_LOCATION 또는 ACCESS_COARSE_LOCATION   
백그라운드 위치 접근에는 ACCESS_BACKGROUND_LOCATION 권한이 **추가로** 필요하다.    
안드로이드 10 (API 레벨 29)부터 백그라운드 위치를 요청하는 앱은 먼저 포그라운드 접근 권한을 요청한 다음 별도로 백그라운드 권한을 요청해야 한다.

| **일회성 권한**   
안드로이드 11(API 레벨 30)부터 위치, 카메라, 마이크에 대해 일회성 권한이 도입됐다.   

## 실전 질문
Q) 안드로이드의 런타임 권한 시스템은 사용자 개인 정보를 어떻게 보호하며, 민감한 권한을 요청하기 전에 앱은 어떤 시나리오를 고려해야 하나요?   
A) 런타임 권한 시스템은 해당 권한이 실제로 필요할 때 요청하고 각 권한을 일부는 허용하고 일부는 거부하는 세부적인 제어 및 자유롭게 권한 철회를 제공함으로서 사용자 개인 정보를 보호한다.   
민감한 권한을 요청하기 전에 개발자는 실제로 해당 권한이 필요한지, 어디서 필요한지, 거부 및 영구 거부했을 때를 고려해야 하며 권한을 요청할 때 어째서 해당 권한이 필요한지 사용자에게 제공해야함을 생각해야 한다.

# Q23 Looper, Handler, HandlerThread의 역할은 무엇인가요?
Looper, Handler, HandlerThread는 스레드를 관리하고 비동기 통신을 처리하기 위해 함께 작동하는 컴포넌트이다.   
이들은 백그라운드 스레드에서 작업을 수행하며 UI 업데이트를 위해 메인 스레드와 상호 작용하기 위한 필수적인 컴포넌트이다.  

| **Looper**
Looper는 스레드를 살아있게 유지하여 메시지 또는 작업 큐를 순차적으로 처리하는 안드로이드 스레딩 모델의 일부   
안드로이드 메인 스레드(UI 스레드) 및 다른 워커 스레드에서 중심적인 역할을 한다.   

+ 목적 : 메시지 큐를 지속적으로 모니터링하고 메시지나 작업을 적절한 핸들러에 가져와 디스패치한다.   
+ 사용법 : 메시지를 처리하는 모든 스레드에는 Looper가 필요하다. 메인 스레드에는 자동으로 Looper가 있지만 워커 스레드의 경우 명시적으로 준비해야 한다.
+ 초기화 : `Looper.prepare()`를 사용하여 스레드에 Looper를 연결하고 `Looper.loop()`를 사용하여 루프를 시작한다.

| **Handler**
Handler는 스레드의 메시지 내에서 메시지나 작업을 보내고 처리하는데 사용한다.   
Looper와 함께 작동

+ 목적 : 한 스레드에서 다른 스레드로 작업이나 메시지를 전달(ex. 백그라운드 스레드에서 UI 업데이트하기)
+ 동작 : Handler가 생성될 때, 생성된 스레드 및 해당 스레드의 Looper에 연결된다. Handler로 전송된 작업은 해당 스레드에서 처리된다.

| **HandlerThread**
HandlerThread는 내장된 Looper를 가진 특수한 Thread이다.   
작업이나 메시지 큐를 처리할 수 있는 백그라운드 스레드를 생성하는 과정을 단순화한다.

+ 목적 : 자체 Looper를 가진 워커 스레드를 생성하여 해당 스레드에서 작업을 순차적으로 처리할 수 있도록 한다.
+ 생명주기 : `start()`로 HandlerThread를 시작한 다음 `getLooper()`를 사용하여 Looper를 얻는다. 리소스를 해제하려면 항상 `quit()` 또는 `quitSafely()`를 사용하여 Looper를 종료해야 한다.

**차이점 및 관계**   
1. Looper : 메시지 처리의 중추, 스레드를 살아있게 유지하고 메시지 큐를 처리한다.
2. Handler : Looper와 상호작용하며 메시지와 작업을 큐에 넣거나 처리한다.
3. HandlerThread : 자동 Looper 설정으로 백그라운드 스레드 생성을 단순화한다.

**사용 사례**   
+ Looper : 메인 스레드 또는 워커 스레드에서 연속적인 메시지 큐 관리
+ Handler : 스레드간 통신
+ HandlerThread : 데이터 처리나 네트워크 요청과 같이 전용 스레드가 필요한 백그라운드 작업

## 실전 질문
Q) Handler는 Looper와 어떻게 작동하여 스레드 간 통신을 용이하게 하며, Handler의 일반적인 사용 사례를 말씀해주세요.   
A) Handler는 다른 스레드의 메시지 큐에 메시지를 보낸다. 해당 스레드의 Looper는 이 메시지 큐에서 작업을 꺼내 처리한다. 백그라운드 스레드에서 UI를 업데이트할 때 주로 사용한다.

Q) HandlerThread란 무엇이며, Looper.prepare()를 사용하여 수동으로 스레드를 생성하는 것과 비교하여 백그라운드 스레드 관리를 어떻게 단순화하나요?   
A) 자체적인 Looper를 가지고 있는 스레드이다.   
Looper.prepare()를 사용하는 방식은 `Looper.prepare()`과 `Looper.loop()`를 직접 호출하지만 HandlerThread는 `handlerThread.start()`를 호출하는 것으로 두 작업을 알아서 수행한다.   
또한 Looper.prepare()방식에서 스레드를 start()한 직후 메인 스레드에서 해당 스레드의 Looper에 접근하려고 하면 아직 Looper.prepare()가 실행되기 전이라 null을 반환받아 crush가 발생할 수 있다.   
하지만 HandlerThread는 handlerThread.start() 호출 후 handlerThread.getLooper()를 호출하면 HandlerThread는 내부적으로 Looper가 완전히 준비될 때까지 기다렸다가 안전하게 Looper를 반환한다.

# Q24 예외(exceptions)를 어떻게 추적하나요?
| **try-catch를 이용한 예외처리**   
```kotlin
try {
   val result = performRiskyOperation()
} catch (e: Exception) {
   Log.e("Error", "Exception occurred: ${e.message}", e)
}
```
Logcat에 기록되어 추적 및 해결 용이

| **전역 예외 핸들러 사용하기**   
`Thread.setDefaultUncaughtExceptionHandler`를 사용하여 전역 예외 핸들러를 설정하면 앱 전체에서 처리되지 않은 예외를 포착하는데 도움이 된다.   
중앙집중식 오류 보고/로깅에 유용함

```kotlin
val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
    Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}:${exception.message}", exception)
    // 예외 세부 정보 저장 또는 서드 파티 솔루션으로 전송 (Crashlytics 등)
    // FirebaseCrashlytics.getInstance().recordException(exception)
    // 기존 핸들러 호출 (선택 사항, 시스템 기본 크래시 동작 유지)
    defaultHandler?.uncaughtException(thread, exception)
}
```
이 방법은 애플리케이션 전체의 런타임 문제를 디버깅하고 모니터링하는데 효과적이다.   
디버그 또는 QA 빌드에서만 전역 예외 핸들러를 구현할 수 있다.   

| **Firebase Crashlytics 사용하기**    
Firebase Crashlytics는 프로덕션 환경에서 예외를 추적하는 도구로 처리되지 않은 예외를 자동으로 기록하고 스택 트레이스, 기기 상태 및 사용자 정보와 함께 자세한 크래시 보고서를 제공한다.   
```kotlin
try {
    val data = fetchData()
} catch (e: IOException) {
    FirebaseCrashlytics.getInstance().recordException(e)
}
```

| **브레이크포인트(Breakpoints)를 이용한 디버깅**      
Android Studio에서 브레이크포인트를 찍으면 코드 실행을 일시 중지하고 앱 상태를 점진적으로 검사할 수 있다.   
이는 개발 중에 예외의 원인을 식별하는 데 특히 유용, 디버그 모드를 활성화하고 브레이크포인트에 도달했을 때 변수, 메서드 호출 및 예외 스택 트레이스를 상세하게 탐색 가능   

| **버그 리포트 캡처하기**    
기본적으로 ADB는 서드파티 솔루션 없이 버그 리포트를 캡처하고 생성하는 방법을 제공한다.   
버그 리프토는 다음과 같은 세 단계로 생성된다.   
1. 개발자 옵션 : 개발자 옵션을 활성화하고, 설정 > 개발자 옵션 > 버그 신고로 이동하여 버그 신고 유형을 선택하고 생성된 보고서 공유
2. Android Emulator에서 버그 신고 캡처 : 확장 컨트롤을 열고 버그 신고를 선택한 다음 관련 세부 정보와 함께 보고서를 저장
3. ADB(Android Debug Bridge)를 사용하여 버그 신고 캡처 : 터미널에서 `adb bugreport/path/to/save/bugreport`를 실행하거나, `adb ‑s <device_serial_number> bugreport`로 특정 기기 지정

생성된 ZIP 파일에는 디버깅에 필수적인 dumpsys, dumpstate, logcat과 같은 로그가 포함되어 이다.

## 실전 질문
Q) Logcat을 사용하여 개발 환경에서 예외를 디버깅하는 것과 Firebase Crashlytics와 같은 도구를 사용하여 프로덕션 환경에서 예외를 처리하는 것의 차이점은 무엇인가요? 또한, Logcat과 같은 로컬 환경에서 추적된 예외랑 프로덕션에서 추적된 예외를 각각 어떻게 해결하시나요?   
A) Logcat은 문제를 실시간으로 확인하고 디버깅하는 용도, Firebase Crashlytics는 이미 배포된 프로덕션 환경에서 발생하는 예외를 수집/집계하여 모니터링하는 용도로 Logcat은 로컬환경만을 Firebase Crashlytics는 모든 사용자기기에서 예외를 수집한다.   
Logcat으로 추적된 예외는 스택트레이스를 분석하여 실제 문제가 발생한 코드로 이동한 후 디버깅을 한다(수정, 재현 등), 프로덕션에서 추적된 예외는 발생 빈도, 경험 사용자수 등을 고려하여 우선순위를 선정하고 해당 에러가 특수한 OS 등의 환경에서만 발생하는 문제인지 확인한다. 이후 개발 환경에서 동일하게 예외를 발생시킨 후 문제를 해결한다. 만약 문제를 재현할 수 없고 분석하기 어렵다면 커스텀 로그를 빽빽히 추가하여 데이터를 다시 확보한다.   

# Q25 빌드 변형(build variants)과 플레이버(flavors)란 무엇인가요?
Build Variants와 flavors를 통해 단일 코드베이스에서 애플리케이션의 다양한 버전을 생성하는 유연한 방법을 제공한다.   
이 시스템을 통해 개발자는 동일한 프로젝트 내에서 개발 및 프로덕션 빌드 또는 무료/유료 버전과 같은 여러 구성을 효율적으로 관리할 수 있다.   

| **빌드 변형(Build Variants)**   
빌드 변형은 특정 빌드 타입과 제품 플레이버(product flavor)를 결합한 결과물이다.   
안드로이드 Gradle 플러그인은 각 조합에 대해 빌드 변형을 생성하여 다양한 사용 사례에 맞는 APK 또는 번들을 생성할 수 있도록 한다.   

빌드 타입은 애플리케이션이 어떻게 빌드되는지를 나타내며, 일반적으로 디버그와 릴리스를 포함한다.   

| **제품 플레이버(Product Flavor)**   
제품 플레이버를 통해 개발자는 무료 및 유료 버전이나 us 및 eu와 같은 지역별 버전과 같이 다양한 변형을 정의할 수 있다.   
각 플레이버는 애플리케이션 ID, 버전 이름, 리소스와 같은 고유한 구성을 가질 수 있다.   
이를 통해 코드를 복제하지 않고 맞춤형 빌드를 쉽게 만들 수 있다.

**빌드 변형 및 플레이버 사용의 이점**   
1. 효율적인 구성 : 프로젝트를 통째로 복사할 필요가 없어 중복 코드를 줄이고 단일 코드베이스에서 여러 빌드 처리 가능
2. 커스텀 동작 : 유료 버전에서 프리미엄 기능을 활성화하거나 디버그와 릴리스 빌드에서 각각 다른 API를 사용하는 등 앱 동작을 맞춤 설정할 수 있다.
3. 자동화 : Gradle은 빌드 변형에 따라 APK 서명, 최적화 및 난독화와 같은 작업을 자동화한다.

## 실전 질문
Q) 빌드 타입과 제품 플레이버의 차이점은 무엇이며, 빌드 변형을 생성하기 위해 그 두 가지가 어떤 식으로 함께 작동하나요?   
A) 빌드 타입은 애플리케이션이 난독화, 디버그 설정 및 서명 등 어떻게 빌드할지를 나타내며, 플레이버는 소스셋 등 무엇을 빌드할지를 나타낸다.    
빌드 타입과 플레이버의 조합으로 빌드 변형을 생성하는데 각 빌드 타입과 플레이버의 데카르트 곱으로 생성된다.

# Q26 접근성(accessibility)을 어떻게 보장하나요?
접근성은 시각. 청각 또는 신체 장애가 있는 사람들을 포함한 모든 사람이 애플리케이션을 사용할 수 있도록 보장하는 것을 말한다.   
접근성 기능을 구현하면 사용자 경험이 풍부해지고 WCAG와 같은 글로벌 접근성 표준 준수를 보장할 수 있다.

| **콘텐츠 설명(Content Descriptions) 활용하기**   
콘텐츠 설명은 UI 컴포넌트에 텍스트 레이블을 제공하여 스크린 리더가 시각 장애가 있는 사용자에게 해당 컴포넌트를 알릴 수 있도록 한다.   
`android:contentDescription` 속성 사용, Compose에도 버튼 등의 컴포넌트에 `contentDescription` 파라미터 사용   

| **동적 글꼴 크기 지원하기**    
앱이 기기 설정에 따라 사용자가 설정한 글꼴 크기 환경 설정을 존중하도록 보장한다.   
접근성 설정에 따라 자동으로 크기가 조정되도록 텍스트 크기에는 `sp` 단위를 사용한다.

| **포커스 관리 및 탐색**   
커스텀 뷰, 다이얼로그, 양식의 경우 포커스 동작을 적절히 관리한다.   
키보드 및 D-패드 사용자를 위한 논리적인 탐색 경로를 정의하려면 `android:nextFocusDown`, `android:nextFocusUp` 및 관련 속성을 사용한다.   
스크린 리더로 앱을 테스트하여 요소간 포커스 이동이 자연스러운지 확인한다.

| **색상 대비 및 시각적 접근성**   
저시력 또는 색맹 사용자의 가독성을 향상시키기 위해 텍스트와 배경색 간에 충분한 대비를 제공한다.   
Accessibility Scanner와 같은 도구로 앱의 색상 대비를 평가하고 최적화할 수 있다. 

| **커스텀 뷰 및 접근성**   
커스텀 뷰를 만들때 AccessibilityDelegate를 구현하여 스크린 리더가 커스터 UI 컴포넌트와 상호작용하는 방식을 정의할 수 있다.   
커스텀 컴포넌트에 의미있는 설명을 제공하려면 `onInitializeAccessibilityNodeInfo()` 메서드를 재정의한다.   

| **접근성 테스트하기**   
Accessibility Scanner 및 Layout Inspector와 같은 도구를 사용해 접근성 문제를 식별하고 수정한다.   

## 실전 질문
Q) 동적인 글꼴 사이즈를 지원하기 위한 모범 사례는 무엇이고, 텍스트 크기에 dp 단위보다 sp 단위를 사용하는 것이 선호되는 이유는 무엇인가요?   
A) 텍스트 단위를 sp를 사용한다. dp는 화면 밀도에만 영향을 받는다. 예를 들어 dp는 어느 화면에서나 비슷한 크기를 유지하지만 사용자 설정을 무시한다. 그러나 sp는 화면 밀도를 고려할 뿐 아니라 글꼴 설정의 Scale(배율)값도 고려한다.   

Q) 개발자는 보조 기술에 의존하는 사용자를 위해 적절한 포커스 관리 및 탐색을 어떻게 보장할 수 있으며, 접근성 문제를 테스트하는 데 도움이 되는 안드로이드 도구에는 어떤 것이 있나요?   
A) contentDescription을 활용하고 `android:nextFocusDown`, `android:nextFocusUp`와 `FocusManager`를 활용하여 포커스 관리 및 탐색을 보장한다.   
Accessibility Scanner, Layout Inspector로 접근성 문제를 테스트할 수 있다.   

# Q27 안드로이드 파일 시스템이란 무엇인가요?   
안드로이드 파일 시스템은 안드로이드 기기에서 데이터 저장을 관리하고 구성하는 구조화된 환경을 말한다.   
애플리케이션과 사용자가 파일을 효율적으로 저장, 검색 및 관리할 수 있도록 한다.   
파일 시스템은 리눅스의 파일 시스템 아키텍처 위에 구축되어 엄격한 보안 및 권한 모델을 준수하며 비공개 및 공유 저장 공간을 모두 제공한다.   

| **안드로이드 파일 시스템의 주요 구성 요소**   
+ System Partition (/system) : 안드로이드 프레임워크 라이브러리, 시스템 앱 및 구성 파일을 포함한 핵심 운영 체제 파일이 들어 있다. 이 파티션은 우발적이거나 악의적인 수정을 방지하고자 일반 사용자 및 앱에 대해 읽기 전용
+ Data Partition (/data) : 데이터베이스, `SharedPreferences` 및 사용자가 생성한 파일을 포함한 앱별 데이터가 저장된다. 각 앱은 /data/data 내에 해당 앱만 접근할 수 있는 비공개 디렉토리를 가지므로 데이터 보안이 보장된다.   
+ Cache partition (/cache) : 시스템 업데이트나 기기 재시작 시 유지할 필요가 없는 캐시된 파일과 같은 임시 데이터 저장에 사용
+ External Storage (/sdcard or /storage) : 여러 앱에서 접근할 수 있는 공유 저장 공간을 제공하며, 이미지, 비디오, 문서와 같은 미디어 파일에 자주 사용된다. 내부/이동식 SD 카드일 수 있음
+ Temporary Files (/tmp) : 앱 실행 중 임시 파일을 저장하는 위치, 일반적으로 앱이나 시스템이 재시작될 때 사라짐

| **안드로이드에서 파일 접근하기**   
애플리케이션은 안드로이드 프레임워크에서 제공하는 API를 사용하여 파일 시스템과 상호작용한다.   
필요한 파일 가시성 및 수명에 따라 앱은 파일을 다른 위치에 저장할 수 있다.   
+ 내부 저장소(Internal Storage) : 애플리케이션 샌드박스 내의 비공개 저장공간, 해당 앱만 접근 가능, 민감하거나 앱별 데이터 저장에 이상적
+ 외부 저장소(External Storage) : 여러 앱에서 접근할 수 있는 공유 저장 공간, 사용자가 앱 외부에서 접근할 것으로 예상하는 사용자 생성 콘텐츠 또는 미디어 저장에 사용

| **파일 권한 및 보안**   
+ 비공개 앱 데이터 : 앱의 내부 저장소에 저장된 파일은 비공개이며 해당 앱만 접근할 수 있다.   
+ 공유 파일 : 앱 간에 파일을 공유하려면 개발자는 외부 저장소나 적절한 권한이 있는 ContentProvider를 사용할 수 있다.
+ 범위 지정 저장소(Scoped Storage) : 안드로이드 10에서 도입되었으며 공유 저장소에 대한 직접 접근을제한하여 앱이 `MediaStore`또는 SAF(Storage Access Framework) API를 사용하도록 요구한다.   

## 실전 질문
Q) 안드로이드는 파일 시스템에서 보안 및 권한을 어떻게 관리하며, 앱이 서로의 비공개 데이터에 접근할 수 없도록 보장하는 메커니즘은 무엇인가요?   
A) 애플리케이션 샌드박스로 보안 규칙 및 권한을 제어하며 Data Partition에 실제 데이터를 저장한다.   
안드로이드는 각 앱에 고유한 UID를 할당한다. 커널은 앱에 할당된 사용자 및 그룹 ID와 같은 표준 Linux 시설을 통해 액세스를 제한하여 프로세스 수준에서 앱과 시스템 간의 보안을 강화한다.

참고
+ 앱의 캐시 데이터는 /data/data/<패키지명>/cache에 저장된다.
+ 애플리케이션 샌드박스 : 운영체제가 각 애플리케이션을 서로 격리된 환경에서 실행시키는 보안 모델로 앱 샌드박스는 규칙이고 /data/data가 그에 따라 할당된 실제 공간

# Q28 안드로이드 런타임(ART), Dalvik, Dex 컴파일러란 무엇인가요?
| **안드로이드 런타임(ART)**   
+ ART는 안드로이드 4.4(KitKat)에서 도입되어 안드로이드 5.0(Lollipop)부터 디폴트로 사용되는 관리형 런타임 환경   
+ Dalvik 대체
+ Ahead-of-Time(AOT) 컴파일을 사용하여 앱을 컴파일, 앱 설치 중에 바이트 코드를 기계 코드로 변환
+ Just-in-Time(JIT) 컴파일의 필요성을 없애 앱 시작 시간을 단축하고 실행 중 CPU 사용량을 줄인다.   
주요 특징
+ 개선된 성능: AOT 컴파일은 최적화된 기계 코드를 생성하여 런타임 오버헤드를 줄인다.
+ 가비지 컬렉션: ART는 더 나은 메모리 관리를 위해 개선된 가비지 컬렉션 기술을 도입
+ 디버깅 및 프로파일링 지원: ART는 개발자를 위해 상세한 스택 트레이스 및 메모리 사용량 분석과 같은 향상된 도구 제공

| **Dalvik**   
Dalvik은 ART 이전에 사용되던 런타임, 가상 머신 환경에서 애플리케이션을 실행하도록 설계되었으며 제한된 메모리와 처리 능력을 위해 최적화되었다.    
+ Just-in-time(JIT) 컴파일 사용, 런타임에 바이트 코드를 기게 코드로 변환
+ 앱 설치에 필요한 시간을 줄이지만, 즉석 컴파일로 인해 오버헤드가 증가      
주요 특징   
+ 컴팩트한 바이트코드 : 낮은 메모리 사용량과 빠른 실행을 위해 최적화된 .dex 파일을 사용
+ 레지스터 기반 VM: 스택 기반(JVM)이 아닌 레지스터 기반으로 명령어 효율성 향상   

느린 앱 시작 시간과 높은 CPU 사용량과 같은 한계로 최신 안드로이드 버전에서는 ART로 대체

| **Dex 컴파일러**   
Java/Kotlin 컴파일러에서 생성된 Java 바이트코드를 .dex(Dalvik Executable) 파일로 변환   
.dex 파일은 컴팩트하며 Dalvik 및 ART 런타임 환경에 최적화되어 있다.   
주요 특징   
+ 멀티덱스(Multi-dex) 지원 : 64K 메서드 제한을 초과하는 애플리케이션의 경우 Dex 컴파일러는 바이트코드를 여러 .dex 파일로 분할하는 것을 지원
+ 바이트코드 최적화: 컴파일러는 안드로이드 기기에서 더 나은 메모리 사용량과 실행 성능을 위해 바이트코드를 최적화

| **Dalvik에서 ART로의 전환**   
ART의 AOT 컴파일, 개선된 가비지 컬렉션 및 프로파일링 기능으로 더 나은 개발자 및 사용자 경험 제공   
Dalvik용으로 설계된 앱은 .dex 파일을 사용하기 때문에 ART와 완벽하게 호환되므로 원활한 마이그레이션 보장

## 실전 질문
Q) ART의 Ahead‑of‑Time (AOT) 컴파일은 Dalvik의 Just‑in‑Time (JIT) 컴파일과 어떻게 다르며, 앱 시작 시간과 CPU 사용량에 어떤 영향을 미치나요?   
A) AOT 컴파일은 앱 설치 중에 바이트 코드를 기계 코드로 컴파일하며 JIT 컴파일은 런타임에 바이트코드를 기계 코드로 컴파일한다.   
AOT는 미리 컴파일을 하여 앱이 시작될 때의 컴파일 필요성을 제거해 앱 시작 속도가 더 빠르고 런타임 때 컴파일을 하지 않아 CPU 사용량도 더 적다.

참고   
+ ART도 레지스터 기반

# Q29 APK 파일과 AAB 파일의 차이점은 무엇인가요?
안드로이드 애플리케이션은 2가지 기봇 포멧인 APK와 AAB를 사용하여 배포 및 설치할 수 있다.   

| **APK(Android Package)**   
+ 안드로이드 애플리케이션을 배포하고 설치하는 전통적인 포멧
+ 앱이 기기에서 작동하는데 필요한 모든 리소스, 코드 및 메타데이터를 포함하는 완전하고 즉시 설치 가능한 패키지
+ 모든 기기 구성(화면 밀도, CPU 아키텍처, 언어)에 대한 모든 리소스를 포함하여 사용자 의 기기와 관련없는 리소스를 포함하게 되어 파일 크기가 커질 수 있음
+ 기기에 직접 설치되며 공식 앱스토어 외부에서 공유하거나 사이드로딩할 수 있음

| **AAB(Android APP Bundle)**   
+ APK와 같은 설치 가능한 형식이 아닌 게시 포멧
+ AAB를 Google Play에 업로드하면 Google Play는 이를 개별 기기에 맞게 최적화된 APK로 처리
+ AAB 파일은 모듈식으로 다른 구성에 대한 리소스와 코드를 별개의 번들로 분리
+ Google Play는 이 모듈식 구조를 사용하여 다운로드 시점에 기기별 APK 생성
+ 특정 화면 크기, CPU 아키텍처 및 언어에 필요한 리소스와 코드만 전달하여 앱 크기를 줄인다
+ Google Play의 서버측에서 처리되므로 직접 설치 불가

| **주요 차이점**    
1. **목적 및 구조**
   + APK : 모든 구성에 대한 모든 리소스와 코드를 포함하는 완전한 패키지
   + AAB : 기기별 APK를 생성하는 모듈식 게시 형식
2. **파일 크기**
   + APK : 모든 기기에 대한 리소스를 포함하여 크기가 더 크다.
   + AAB : 더 작고 최적화된 APK를 생성할 수 있게 하여 사용자에게 전달되는 앱 크기를 줄인다.
3. **배포**
   + APK : 기기에 직접 공유, 사이드로딩 가능
   + AAB : Google Play에 업로드되며 Google Play가 최종 사용자를 위해 최적화된 APK 생성
4. **관리**
   + APK : 개발자가 리소스와 구성을 수동으로 관리
   + AAB : 구성 관리를 Google Play에 위임하여 프로세스 자동화
5. **도구 및 호환성**
   + APK : 모든 안드로이드 기기 및 앱스토어에서 지원됨
   + AAB : 설치 가능한 APK를 생성하기 위해 Google Play 또는 bundletool이 필요, 기본적으로 Google외 앱스토어와 호환안됨

## 실전 질문
Q) AAB 포멧은 어떻게 다양한 기기 구성에 대해서 앱을 최적화하며, 이는 기존 APK 포멧에 비해 어떤 장점이 있나요?   
A) 사용자가 앱 다운을 요청하면 Google Play에서 즉시 앱을 분석하여 사용자의 기기 사양을 파악하는 Dynamic Delivery 후 기기에 필요한 리소스만을 이용해 Split APK를 생성함으로서 최적화   
이를 통해 기존 APK 포멧보다 더 적은 용량을 갖고 개발자는 각 기기환경별 별도의 APK를 만들지 않고 편리하게 빌도 및 배포관리를 할 수 있다.

# Q30 R8 최적화란 무엇인가요?
R8은 안드로이드 빌드 프로세스에서 APK 또는 AAB의 크기를 줄이고 런타임 성능을 향상시키기 위해 사용되는 코드 축소 및 최적화 도구이다.   
이전의 ProGuard 도구를 대체하고 코드 축소, 최적화, 난독화 및 리소스 관리를 위한 향상된 기능을 제공한다.   
| **R8 작동 방식**   
+ 코드 축소(Shrinking) : 애플리케이션 코드베이스에서 사용되지 않는 클래스, 메서드, 필드 및 속성을 제거하여 최종적인 APK/AAB 크기를 줄인다.
+ 최적화(Optimization) : 런타임 성능을 향상시키기 위해 코드를 단순화하고 재구성한다. 여기에는 메서드 인라이닝(inlining), 중복 코드 제거, 동일한 코드 블록 병합 등이 포함된다.
+ 난독화(Obfuscation) : 클래스, 메서드 및 필드의 이름을 변경하여 원래 이름을 모호하게 만들어 리버스 엔지니어링을 더 어렵게 만든다.
+ 리소스 최적화 : 사용되지 않는 리소스(레이아웃, Drawable, 문자열 등)을 제거하여 앱 사이즈를 더욱 최소화한다.

| **주요 특징**   
+ 죽은 코드 제거(Dead Code Removal) : R8은 코드베이스를 분석하여 앱에서 도달할 수 없거나 사요되지 않는 코드를 식별하고 제거한다.
+ 인라이닝(Inlining) : 짧은 메서드나 함수를 호출자 쪽에 직접 인라인하여 메서드 호출 오버헤드를 줄이고 런타임 성능을 향상시킨다.
+ 클래스 병합(Class Merging) : 유사한 클래스나 인터페이스를 하나로 결합하여 메모리 공간을 줄이고 효율성을 향상시킨다.
+ 도달 불가능한 코드 제거(Unreachable Code Elimination) : 실행되지 않는 코드 경로를 완전히 제거한다.
+ 상수 폴딩 및 전파(Constant Folding and Propagation) : 표현식을 단순화하고 변수를 가능한 경우 해당 상수 값으로 대체
+ 난독화(Obfuscation) : 코드의 의미있는 이름을 더 짧고 덜 설명적인 이름으로 대체하여 앱 크기를 줄이고 리버스 엔지니어링을 더 어렵게 만든다.

| **R8 구성**   
R8은 앱 빌드 구성을 위해 ProGuard 규칙을 동일하게 사용한다.   
코드의 어떤 부분을 축소, 난독화 및 최적화에서 제외할지 지정할 수 있다.   
아래와 같이 가능   
+ **리플렉션을 위한 코드 보존** : 리플렉션을 통해 접근하는 클래스나 메서드는 런타임에 해당 패키지 이름을 알아야하기에 ProGuard 규칙에 명시적으로 유지하여 난독화하지 않도록 함
+ **서드파티 라이브러리 제외** : 일부 라이브러리는 내부적으로 리플렉션을 사용할 수도 있고 정상적인 기능 동작을 위해 특정 규칙이 필요할 수 있다.

```
‑keep class com.example.myapp.MyClass { *; } // 클래스를 난독화하지 않고 보존하기 위한 ProGuard 규칙
```
| **장점**   
+ 긴밀한 통합 : R8은 안드로이드 빌드 시스템에 내장되어 있어 일반적인 ProGuard 규칙 외에 추가 설정 필요X
+ 향상된 효율성 : 축소, 최적화 및 난독화를 단일 패스로 결합하여 ProGuard보다 빠르고 효율적
+ 앱 크기 감소 : 사용되지 않는 코드와 리소스를 제거하여 최종 APK 또는 AAB 크기를 크게 줄인다.
+ 향상된 보안 : 난독화는 해커 및 크래커가 앱을 리버스 엔지니어링하기 어렵게 만들어 보안 강화

| **R8의 한게**   
+ 과도한 축소 위험 : 제대로 구성하지 않으면 R8이 간접적으로 참조되는 코드나 리소스를 제거하여 런타임 오류를 유발
+ 복잡한 구성 : 복잡한 프로젝트, 특히 리플렉션이나 동적 클래스 로딩을 사용하는 프로젝트의 경우 ProGuard 규칙 작성이 복잡하고 까다로울 수 있음
+ 디버깅 어려움 : 난독화는 스택 트레이스에 난독화된 이름이 로깅되기에 디버깅을 더 어렵게 만들 수 있음

## 실전 질문
Q) R8 최적화는 앱 성능을 어떻게 개선하고, APK/AAB 용량을 어떻게 줄이나요?   
A) 작고 자주 호출되는 코드를 inlining하여 호출 오버헤드를 제거하고 표현식을 단순화하여 앱 성능을 개선한다.   
사용하지 않거나 도달하지 않는 코드를 제거하는 Shrinking과 변수명을 a, b와 같은 짧고 의미없는 이름으로 바꾸는 Obfuscation을 통해 용량을 줄인다.

Q) R8은 ProGuard와 어떻게 다르며, 어떤 추가적인 장점을 제공하나요?      
A) R8은 .dex 파일로 컴파일하던 d8과 통합되어 축소, 최적화 및 난독화를 단일 패스로 결합해 더 빠르다. 
```kt
internal object PreferencesFileSerializer : Serializer<Preferences> {
   internal const val fileExtension = "preferences_pb"

   override val defaultValue: Preferences
      get() {
         return emptyPreferences()
      }

   @Throws(IOException::class, CorruptionException::class)
   override suspend fun readFrom(input: InputStream): Preferences {
      val preferencesProto = PreferencesMapCompat.readFrom(input)

      val mutablePreferences = mutablePreferencesOf()

      preferencesProto.preferencesMap.forEach { (name, value) ->
         addProtoEntryToPreferences(name, value, mutablePreferences)
      }

      return mutablePreferences.toPreferences()
   }

   @Suppress("InvalidNullabilityOverride") // Remove after b/232460179 is fixed
   @Throws(IOException::class, CorruptionException::class)
   override suspend fun writeTo(t: Preferences, output: OutputStream) {
      val preferences = t.asMap()
      val protoBuilder = PreferenceMap.newBuilder()

      for ((key, value) in preferences) {
         protoBuilder.putPreferences(key.name, getValueProto(value))
      }

      protoBuilder.build().writeTo(output)
   }

   private fun getValueProto(value: Any): Value {
      return when (value) {
         is Boolean -> Value.newBuilder().setBoolean(value).build()
         is Float -> Value.newBuilder().setFloat(value).build()
         is Double -> Value.newBuilder().setDouble(value).build()
         is Int -> Value.newBuilder().setInteger(value).build()
         is Long -> Value.newBuilder().setLong(value).build()
         is String -> Value.newBuilder().setString(value).build()
         is Set<*> ->
            @Suppress("UNCHECKED_CAST")
            Value.newBuilder()
               .setStringSet(StringSet.newBuilder().addAllStrings(value as Set<String>))
               .build()
         is ByteArray -> Value.newBuilder().setBytes(ByteString.copyFrom(value)).build()
         else ->
            throw IllegalStateException(
               "PreferencesSerializer does not support type: ${value.javaClass.name}"
            )
      }
   }

   private fun addProtoEntryToPreferences(
      name: String,
      value: Value,
      mutablePreferences: MutablePreferences
   ) {
      return when (value.valueCase) {
         Value.ValueCase.BOOLEAN ->
            mutablePreferences[booleanPreferencesKey(name)] = value.boolean
         Value.ValueCase.FLOAT -> mutablePreferences[floatPreferencesKey(name)] = value.float
         Value.ValueCase.DOUBLE -> mutablePreferences[doublePreferencesKey(name)] = value.double
         Value.ValueCase.INTEGER -> mutablePreferences[intPreferencesKey(name)] = value.integer
         Value.ValueCase.LONG -> mutablePreferences[longPreferencesKey(name)] = value.long
         Value.ValueCase.STRING -> mutablePreferences[stringPreferencesKey(name)] = value.string
         Value.ValueCase.STRING_SET ->
            mutablePreferences[stringSetPreferencesKey(name)] =
               value.stringSet.stringsList.toSet()
         Value.ValueCase.BYTES ->
            mutablePreferences[byteArrayPreferencesKey(name)] = value.bytes.toByteArray()
         Value.ValueCase.VALUE_NOT_SET -> throw CorruptionException("Value not set.")
         null -> throw CorruptionException("Value case is null.")
      }
   }
}

```