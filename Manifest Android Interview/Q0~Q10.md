# Q0 Jetpack Compose의 동작 구조는 어떻게 이루어져 있나요?
Compose의 구조는 Compose Compiler, Compose Runtime, Compose UI의 3가지 주요 계층으로 이루어져 있다.

| **Compose Compiler**   
+ Kotlin으로 작성된 선언적 UI 코드를 Jetpack Compose가 실행할 수 있는 최적화된 코드로 변환하는 역할
+ 컴파일 타임에 @Composable 함수 처리, 필요한 UI 업데이트 및 Recomposition 로직 생성
+ KAPT, KST와 같은 기존 어노테이션 처리 도구와 달리 Compose Compiler 플러그인은 FIR(Frontend Intermediate Representation)에서 직접 작동

| **Compose Runtime**   
+ recomposition 및 상태 관리를 지원하는데 필요한 핵심 기능 제공
+ 변경 가능한 상태(mutable states) 처리, 스냅샷 관리, 앱 상태 변경시 UI 업데이트 트리거
+ Gap Buffer 자료구조에서 영감을 받은 슬롯 테이블을 사용하여 컴포지션 상태를 메모이징하는 방식으로 작동
+ side-effects 관리, remember를 사용한 상태 보존, 상태 변경시 recomposition 트리거, CompositionLocal을 사용한 컨텍스트별 데이터 저장, Compose 레이아웃 노드 구축 등

### 갭 버퍼에서 링크 테이블로 마이그레이션
안드로이드팀은 현재(2026.01.22 기준) 갭버퍼에서 링크테이블(Link Table) 자료구조로 마이그레이션 중에 있다.

갭 버퍼 기반 기존 구조는 UI가 복잡해져서 배열의 크기가 커지면 중간에 노드를 하나 삽입하기 위해 수많은 데이터를 밀어내야함(Shifting)   
또한 갭을 유지하기 위해 실제 데이터보다 큰 배열을 미리 할당해서 메모리 낭비, 메모리 파편화 문제가 있음

링크테이블은 삽입/삭제 문제를 O(1)로 줄임 -> Compose 런타임은 Recomposition 중에 이미 트리를 순회(Traversing)하고 있기 때문에 현재위치에서 바로 삽입이 일어난다.   
메모리 문제도 해결

| **Compose UI**   
Compose UI 모듈은 근본적으로 안드로이드의 전통적인 UI 시스템 위에서 동작하나 그 위에 동작하는 Compose의 메커니즘이 따로 존재한다.   
그렇기에 복잡한 관계를 이루나 기존의 안드로이드 UI 시스템과 완전히 분리된 개념이라고 생각하기는 어렵다.

## 실전 질문
Q) Compose Compiler의 역할은 무엇이고, KAPT 또는 KSP와 같은 전통적인 어노테이션 프로세서와 어떻게 다른가요?   
A) Compose Compiler는 Kotlin으로 작성된 UI 코드를 Jetpack Compose가 실행할 수 있는 최적화된 코드로 변환하는데 KAPT, KSP는 소스코드를 읽어 그것을 바탕으로 새로운 파일을 생성하여 기존 코드를 수정할 수 없지만 Compose Compiler는 직접 코드를 변조한다는 차이가 있다.

Q) Compose Runtime은 recomposition과 상태를 어떻게 관리하며, 내부적으로 어떤 자료구조를 사용하나요?   
A) Compose Runtime을 상태를 스냅샷으로 관리한다. Compose Runtime은 컴포저블 함수가 실행될 때 어떤 상태 값을 읽었는지 기록해두고 상태 값이 변경되면 스냅샷은 해당 상태를 읽었던 컴포저블을 찾아 RecompositionScope에 Dirty 표시를 남긴다.   
이후 상태가 바뀐 지점과 연결된 가장 작은 단위의 RecompositionScope를 찾아 이전 값과 현재 값을 비교후 값이 같거나 컴파일러가 stable이라고 판단한 데이터라면 recompsition을 건너뛰고 변경이 확정된 부분만 UI 트리에 반영한다.   
이떄 내부적으로는 갭 버퍼 기반 구조인 슬롯 테이블을 사용한다. 

# Q1 Compose 페이즈(phase)에 대해 설명해 주세요.
Jetpack Compose는 UI를 화면에 그릴 때 Composition, Layout, Drawing의 3가지 주요 단계로 나누어진 렌더링 파이프라인을 따른다.

| **Composition**   
Composition 단계에서는 @Composable 함수를 실행하고 UI 트리를 구축하여 컴포저블 함수에 대한 설명을 생성하는 역할을 한다.   
Compose는 초기 UI 구조를 구축하고 Slot Table이라는 데이터 구조에 컴포저블 간의 관계를 기록한다.

| **Composition의 주요 작업**
+ @Composable 함수 실행
+ UI 트리 생성 및 업데이트
+ recomposition을 위한 변경 사항 추적

| **Layout**   
Layout 단계는 Composition 단계 바로 직후에 수행된다.    
제공된 제약 조건에 따라 각 UI 컴포넌트의 크기와 위치를 결정한다.   

| **Layout의 주요 작업**   
+ UI 컴포넌트 측정
+ 너비, 높이 및 위치 정의
+ 부모 컨테이너 내 자식 배치

| **Drawing**   
Composition과 Layout을 마친 UI 컴포넌트가 화면에 렌더링되는 절차   
Skia 그래픽 엔진을 사용하며 커스텀 드로잉 로직은 Compose의 Canvas API를 사용하여 구현 가능

| **Drawing의 주요 작업**   
+ 시각적 요소 렌더링
+ 화면에 UI 컴포넌트 그리기
+ 커스텀 드로잉 작업 적용

## 실전 질문
Q) Composition 단계에서는 어떤 일이 발생하며, recomposition과 어떤 관련이 있나요?   
A) @Composable 함수를 실행하여 UI 트리를 생성/업데이트하며 이를 슬롯 테이블에 기록한다. Recomposition은 이 슬롯테이블을 대조해서 변경된 부분만 찾아 다시 실행한다.

Q) Compose Phase에서 Layout 단계는 어떻게 작동하나요?   
A) Layout은 다음과 같은 3단계 알고리즘을 사용하여 순회환다. 하위 요소 측정(Measure), 자체 크기 결정(Decide own Size), 하위 요소 배치(Place).    
노드가 하위 요소를 측정하고 이러한 측정값을 기반으로 노드가 자체 크기를 결정한다. 이후 각 하위 노드는 노드의 자체 위치를 기준으로 재배치된다.

# Q2 Jetpack Compose가 선언적(declarative) UI 프레임워크라고 불리는 이유는 무엇인가요?
Jetpack Compose는 개발자가 상태 변경시 UI를 어떻게 업데이트할지를 나타내는 것이 아닌 특정 상태에서 UI가 어떻게 보여야 하는지를 설명하는 선언적 UI 프레임워크의 특성을 가지고 있다.

명령형 UI : 개발자가 뷰를 업데이트하고 UI 일관성을 유지하기 위해 수동으로 UI를 업데이트하는 방식

| **Jetpack Compose에서 선언적 UI의 주요 특징**   
+ **상태 주도 UI(State-Driven UI)**
+ **컴포넌트를 함수 또는 클래스로 정의**  
+ **직접적인 데이터 바인딩(Direct Data Binding)**
+ **컴포넌트 멱등성(Component Idempotence)** : 호출 횟수에 관계없이 동일한 입력에 대해 동일한 출력 생성

## 실전 질문
Q) Jetpack Compose의 선언적 UI의 특성은 전통적인 명령형 XML UI 개발과 어떻게 다르며, 어떤 이점을 제공하나요? 또한, 기존 XML UI 개발에 비해서 유의해야 할 사항은 무엇인가요?   
A) XML UI 방식은 개발자가 직접 뷰 객체를 찾아 상태를 수정하는 반면 Jetpack Compose 방식은 데이터 상태에 따른 UI 결과값을 정의하는 방식이다. 기존 XML UI 개발은 XML 코드와 Java/Kotlin 코드로 분리되어 있으나 Jetpack Compose는 Kotlin 코드 하나로 구성되어 코드 가독성 및 유지보수성이 뛰어나다.   
또한 함수 조합을 통해 UI를 조립하여 컴포넌트 단위 개발이 용이하다. 그러나 기존 XML UI 개발에 비해서 Jetpack Compose는 상태가 바뀔 때마다 Recomposition이 매우 빠르게 수시로 다시 실행된다. 그런만큼 함수 내부에 무거운 연산이나 네트워크 호출이 발생할 경우 앱의 성능이 저하되어 생명주기 관리에 유의해야 한다.   
또한 Compose 전용 상태 객체를 사용해야 런타임이 변경을 감지하므로 이에 대한 상태 관리에 유의해야 한다.

Q) Jetpack Compose는 어떻게 컴포저블 함수에 대해 멱등성을 보장하며, 이것이 선언적 UI 시스템에서 중요한 이유가 무엇인가요?   
A) 상태 값들을 슬롯 테이블에 저장하여 함수가 다시 실행되어도 기록된 상태를 참조하여 동일한 결과값을 보장한다. 또한 네트워크 호출 같은 멱등성을 깨뜨리는 작업은 LaunchedEffect 와 같은 전용 API 내부로 격리시켜서 UI 구성과 상태 변경을 철저히 분리함으로서 멱등성을 보장한다.   
이러한 멱등성은 Recomposition 최적화를 위해 중요한데 recomposition을 최적화하기 위해 일부 함수를 건너뛰기도 한다. 만약 이때 멱등성이 보장되지 않는다면 UI의 일관성이 무너지는 상황이 발생할 수 있어 중요하다.

# Q3 recomposition이란 무엇이며 언제 발생하나요? 또한 앱 성능과 어떤 관련이 있나요?
Recomposition은 상태 변경이 발생할 때마다 UI를 다시 그리는 프로세스이다.   
Recomposition이 발생시 Compose는 Composition 단계부터 새롭게 시작하며 컴포저블 노드는 UI 변경 사항을 Compose Runtime에 알리고 업데이트된 UI가 최신 상태를 반영하도록 보장한다.

| **Recomposition이 발생하는 조건**   
1. 매개변수에 변경이 발생했을 때(Input Changes) : 컴포저블 함수는 입력 매개변수가 변경될 때 recomposition을 트리거한다. Compose Runtime은 `equals()` 함수를 사용하여 새 매개변수 값을 이전 매개변수 값과 비교 후 동기화가 필요한 부분에 한해서만 UI를 업데이트한다.
2. 상태 변경이 관찰되었을 떄(Observing State Changes) : Jetpack Compose는 일반적으로 remember 함수와 state API를 함께 사용하여 상태 변경을 모니터링한다. 상태 객체를 메모리에 보존하고 recomposition이 발생시 메모리에 저장된 값을 복원하여 UI에 최신 상태를 일관되게 반영하도록 보장한다.

| **Recomposition과 성능**    
Layout Inspector : 에뮬레이터나 실제 기기에서 실행 중인 앱의 Compose 레이아웃을 트래킹하여 컴포저블이 얼마나 recompose되는지나 recomposition을 건너뛰는지 모니터링할 수 있다.   
Composition Tracing : 시스템 추적을 통해 오버헤드가 낮은 측정을 제공하고 메서드 추적을 통해 세부적인 함수 호출 추적을 제공한다.    

## 실전 질문
Q) 불필요한 recomposition을 줄이고 앱 성능을 최적화해보신 경험이 있나요? 앱 성능을 향상 시키기 위해 어떤 전략을 사용해 볼 수 있을까요?    
A) list, map, set 같은 컬렉션은 인터페이스로 내부가 변할 수 있어 unstable로 분류된다. 그렇기에 @Immutable 어노테이션이나 @Stable 어노테이션을 사용하여 컴파일러가 건너뛸 수 있도록 한다.    
또한 Lambda Modifier를 활용하여 State를 읽는 시점을 늦출 수 있고 derivedStateOf를 활용해볼 수 있다.


# Q4 Composable 함수는 내부적으로 어떻게 작동하나요?
Compose는 일반적인 함수를 선언적 UI로 동작시키기 위해 @Composable 어노테이션을 사용하고 이 어노테이션이 붙은 함수는 컴파일 타임시 Compose Compiler Plugin에 의해 상태 기반 UI 코드로 변환된다.   

| **컴파일러 변환 (Compiler Transformation)**   
@Composable 어노테이션을 추가하면 Compose Compiler Plugin이 Kotlin 컴파일 프로세스를 가로챈다.   
이때 Compose의 반응형 시스템을 추가하기 위해 기존 함수에 추가적인 매개변수와 로직을 주입하는데 이때 가장 중요한 매개변수 중 하나는 **Composer**로 컴포지션 상태를 추적하고 UI 상태가 변경될 떄 recomposition을 처리한다.

| **컴포지션 및 리컴포지션**   
Compose Runtime은 @Composable 함수의 생명주기를 관리한다.   
Compose Phase의 첫 단계인 Composition 단계에서 런타임은 컴포저블 함수를 실행하고 UI 트리를 구축한다.   
UI 트리는 Slot Table이라는 데이터 구조에 저장된다.   
상태가 변경되면 recomposition이 트리거 되는데 이때 업데이트해야 하는 UI 트리를 다시 빌드하는 대신 Compose는 Slot Table만 사용하여 UI의 어떤 부분을 업데이트해야 하는지 결정하고 해당 컴포저블 함수만 선택적으로 다시 실행한다.

| **Remember 및 상태 관리**   
상태를 관리하고자 Compose는 remember 및 State와 같은 API를 제공한다.

## 실전 질문
Q) 함수에 @Composable 어노테이션을 추가하면 컴파일 시 내부적으로 어떻게 동작하고, 이것이 Jetpack Compose를 선언형 UI로 작동하도록 하는 데 어떤 역할을 하나요?   
A) 내부적으로 Compose Compiler Plugin을 활용하여 Kotlin 코드를 Compose Runtime에서 관리하는 반응형 UI 컴포넌트로 변환한다. 이때 각 컴포저블 함수에 Composer라는 매개변수가 주입되어 실행중 슬롯테이블을 통해 recomposition을 효율적으로 수행할 수 있다.   
결과적으로 개발자는 뷰 객체를 직접 조작하지 않고 데이터 상태에 따른 UI 결과물만 정의하는 선언형 방식에 집중할 수 있다. 즉, 일반 함수를 UI 상태를 구독하고 스스로 갱신할 수 있도록 하는 역할을 수행한다.

### Compose Compiler와 Composer
Compose Compiler는 빌드 프로세스 중 @Composable 함수의 중간 표현(IR)을 최적화된 코드로 변환한다.   

| **Composable 함수 변환**   
일반적인 Kotlin 함수에 @Composable 어노테이션을 달면 Compose 컴파일러는 해당 함수에 Composer라는 암시적 매개변수를 추가하여 함수 자체를 바꾼다.   
Composer는 컴포저블 함수와 Compose Runtime 같의 다리 역할을 하여 런타임이 UI 상태, recomposition 및 기타 핵심 기능을 효율적으로 관리할 수 있도록 한다.   

| **Composer의 역할**   
1. **상태 관리** : 상태를 추적하고 매개변수 입력값이 변경될 때 컴포저블 함수가 올바르게 recompose 되도록 보장한다.
2. **UI 계층 구조 구성** : UI의 트리 구조를 유지하고 상태가 변경됨에 따라 노드를 효율적으로 업데이트한다.
3. **최적화** : 입력 매개변수의 변경 사항을 추적하여 UI의 어떤 부분을 recompose해야 하는지 결정한다.
4. **리컴포지션 제어** : 특정 컴포저블에 대한 recomposition 시작, 건너뛰기 또는 종료를 포함한 recomposition의 생명주기를 조정한다.

### 컴포저블 함수 내에서 직접 비즈니스 로직 호출을 피해야 하는 이유
현재는 컴포저블 함수가 멀티 스레드 환경에서 실행되지 않고 메인 스레드에서 작동되지만 추후에는 컴포저블 함수를 멀티스레드 환경에서 실행하는 것을 고려중에 있다고 한다.   
그렇기에 멀티스레드 환경에서 컴포저블이 돌아갈 가능성을 염두하고 코드를 작성해야 하며 이때 준수해야할 것은 다음과 같다.   
+ **사이드 이펙트 방지** : 외부 상태나 해당 범위내 변수를 컴포저블 함수 내에서 직접적으로 수정하거나 무언가를 요청하지 않아야 한다. (ex. 사이드 이펙트 핸들러 API(SideEffect, LaunchedEffect))
+ **콜백에서 사이드 이펙트 트리거** : 사이드 이펙트를 발생시킬 수 있는 모든 UI 관련 상호작용 작업에는 onClick과 같은 항상 UI 스레드에서 실행되는 콜백을 사용하여 일관성을 보장한다.
+ **가변적인 상태 피하기** : 가변 변수(var 등)를 통해 UI를 업데이트하는 것은 멀티 스레드 환경에서 안전하지 않아 컴포저블 함수 내에서 이와 같은 공유 변수를 사용하여 UI를 업데이트하지 않고 remember와 State를 올바르게 사용해야 한다.

| **어떤 순서로도 실행될 수 있는 Composable 함수**   
Jetpack Compose는 멀티스레딩을 염두하고 설계되어 컴포저블 함수에 대해서 Compose는 순서 그대로의 동작을 보장하지 않는다.

# Q5 Jetpack Compose의 안정성(stability)이란 무엇이며, 성능과 어떤 관련이 있나요?
Jetpack Compose의 Stability : 클래스나 타입이 동일한 매개변수 입력값에 대해 일관된 결과를 생성하도록 보장하는 속성

| **Stable vs Unstable**   
**Stable**
+ String을 포함한 **Primitive Types**이 읽기 전용인 val로 정의된다면 고유한 값은 변경되지 않아 stable
+ 값을 캡처하지 않는 람다 표현식과 같은 **함수 타입**도 동작이 예측 가능하여 stable
+ **클래스**, 특히 읽기 전용(val)이나 변경 불가능(Immutable)하고 stable한 public 속성을 가진 데이터 클래스는 stable
+ @Stable, @Immutable 어노테이션이 명시적으로 붙어있는 클래스는 stable

**Unstable**   
+ 인터페이스 및 추상 클래스 : List, Map 또는 Any와 같은 인터페이스는 컴파일 시점에 구현체의 종류를 보장할 수 없기 때문에 반드시 unstable
+ 가변적인 프로퍼티를 가진 클래스 : 하나 이상의 가변적이거나 본질적으로 불안정하다고 간주되는 타입의 public 프로퍼티를 단 하나라도 포함하는 클래스는 unstable

| **Composable 함수 추론하기**   
Compose 컴파일러는 성능을 최적화하기 위해 컴포저블 함수를 Restartable, Skippable, Moveable, Replaceable과 같은 유형으로 분류한다.   
+ **Restartable** : Restartable로 분류된 함수는 recomposition 프로세스의 기반을 형성한다. 매개변수 입력값 또는 상태가 변경되면 Compose 런타임은 UI를 업데이트하기 위한 recomposition을 위해 함수를 재호출한다. 대부분의 컴포저블 함수는 Restartable로 간주되므로 런타임이 필요할 때마다 recomposition을 트리거할 수 있다.
+ **Skippable** : Skippable 함수는 스마트 recomposition에 의해 활성화된 특정 조건 하에서 recomposition을 건너뛸 수 있다. recomposition을 건너뛰면 하위 함수를 재호출하지 않아도 된다. 컴포저블 함수는 Restartable이면서 Skippable일 수 있고 이는 필요할 때 recomposition을 수행할 수 있으나 조건이 허용되면 건너뛸 수 있음을 의미한다.
+ **Moveable** : Moveable 함수는 컴포저블이 UI 트리 내의 위치가 바뀌어도 자신의 상태(remember된 값들)를 잃지 않고 그대로 들고 이동할 수 있다. 예를 들어 리스트 아이템을 그릴 때 key함수를 사용하여 위치가 바뀌어도 상태를 초기화하지 않는다.
+ **Replaceable** : Replaceable 함수는 컴포저블이 다른 컴포저블로 완전히 대체될 수 있거나, 혹은 그 자리에서 새로 생성되어야 한다. 예를 들어 if-else 문이나 when 문처럼 조건에 따라 다른 컴포저블이 호출될 때 런타임이 해당 슬롯 테이블의 그룹을 삭제하고 새 그룹을 작성한다. Restartable은 함수를 다시 시작하는 것이 중점이라면 Replaceable은 해당 위치의 노드 자체를 갈아끼우는 동작에 가깝다

## 실전 질문
Q) Compose 컴파일러는 매개변수가 stable인지 unstable인지 어떻게 결정하며, 이것이 recomposition 동작에 어떤 영향을 미치나요?   
A) Compose 컴파일러는 모든 public 파라미터가 val이고 해당 타입이 Primitive 타입이거나 stable 할 경우 stable로 인터페이스거나 외부 라이브러리 클래스, var이면 unstable로 분류한다. 이것은 recomposition에서 skippable에 영향을 미치는데 만약 stable하다면 단순 equals() 비교로 같다면 건너뛰지만 unstable할 경우에는 무조건 다시 실행된다.   

Q) Jetpack Compose의 @Stable 및 @Immutable 어노테이션은 무엇이며 어디에, 어떻게 사용해야 하나요?   
A) @Stable은 값은 변경될 수 있지만 변경 시 Compose 시스템에 통보됨을 보장할 때 사용하고 @Immutable은 모든 프로퍼티가 생성 후 변하지 않음을 보장할 때 사용한다. 주로 외부 라이브러리나 인터페이스를 포함한 클래스같은 컴파일러가 자동으로 안정성을 추론하지 못하는 경우 사용한다.

### Smart Recomposition이란?
| **Smart Recomposition 작동 방식**   
새로운 매개변수 입력값이 컴포저블 함수에 전달될 때마다 Compose는 클래스의 equals() 메서드를 사용하여 이전 값과 비교한다.   
+ Stable 매개변수, 입력값 변화 없음 : recomposition을 건너뜀
+ Stable 매개변수, 입력값 바뀜 : recomposition을 틜거하여 UI가 업데이트된 상태 반영하도록 보장
+ Unstable 매개변수 : 항상 recomposition

-> 중복된 Recomposition을 줄이면 산술 오버헤드가 감소하여 UI 성능이 향상된다.

### 안정성 어노테이션(stability annotations)의 종류와 각 차이점
| **@Immutable**   
+ 클래스의 모든 속성을 변경 불가능한 것으로 간주
+ 일반적으로 가변적인 프로퍼티가 없는 클래스에 사용된다.
+ 클래스 내 상태 변경이 없음을 보장하여 Compose 컴파일러의 부담을 덜고 UI 성능 최적화를 단순화한다.

| **@Stable**   
+ 일부 가변 속성을 허용하지만 클래스의 전반적인 안정성을 보장한다.
+ 특정 가변성이 내부적으로 잘 관리되는 클래스에 적합하다.
+ 완전한 불변성을 보장할 수 없는 경우 유연하게 사용 가능

| **@Immutable과 @Stable의 차이점**   

| 특성                |                      @Immutable                       |               @Stable               |   
|:------------------|:-----------------------------------------------------:|:-----------------------------------:|    
| 불변성  요구사항         |                 모든 프로퍼티를 불변으로 간주해야 함                  |     일부 프로퍼티에 대해 제어가 가능한 가변성 허용      |
| UseCae            |              변경이 완전히 불가능해야 하는 데이터 모델 클래스              |     UI 상태와 같이 제어할 수 있는 가변적인 클래스     |
| Recomposition 동작  | 동일한 매개변수를 가진 종속 Composable에 대해 recomposition을 완전히 건너뜀 | 가변 프로퍼티가 변경되면 recomposition 트리거 가능  |

### @Immutable 대신 @Stable를 잘못 사용한다면?
현재는 @Immutable과 @Stable 어노테이션에 대해 Compose Compiler가 처리하는 방식에 기능적인 차이가 없으나 차후 구분에 대한 가능성을 열어두기 위해 구분해서 사용하는 것이 옳다.

# Q6 안정성(stabilities) 개선을 통해 Compose 성능을 최적화한 경험이 있나요?
| **Immutable Collections**   
kotlinx.collections.immutable 이나 Guava의 immutable 컬렉션을 사용하여 ImmutableList 및 ImmutableSet과 같은 불가변성을 지닌 컬렉션을 통해 읽기 전용으로 제어하여 효율적인 recomposition이 가능하다.

ImmutableList는 컴파일러 내부에서 stable로 처리하도록 하드코딩되어있다.

| **Lambda Stability**   
Compose 컴파일러는 람다 표현식을 매개변수로 받는 경우 반드시 stable로 처리하지만 내부적으로 람다가 람다식 스코프의 외부 변수를 참조하는지 여부에 따라 다르게 처리한다.   
+ **값을 캡처하지 않는 람다** : 외부 변수에 의존하지 않는 람다는 싱글톤으로 최적화되어 stable로 간주돼 recomposition을 트리거하지 않음
+ **값을 캡처하는 람다** : 외부 변수에 의존하는 람다는 동적으로 변경 사항에 응답하기 위해 remember를 사용하여 메모이제이션된다. 변경 사항을 관찰하기 위해 외부 변수가 remember API의 key 매개변수로 전달되어 동일한 key값에 대해서는 동일한 리턴값이 나오는 걸 의미하기에 멱등성의 원리를 준수하여 stable로 간주된다.

| **래퍼 클래스 (Wrapper Class)**   
Unstable한 클래스(ex 서브파티 라이브러리 제공 클래스)의 경우에는 해당 클래스를 감싸는 Wrapper Class를 만들고 이에 @Immutable이나 @Stable같은 안정성 어노테이션을 사용할 수 있다.

| **안정성 구성 파일 (Stability Configuration File)**   
Compose Compiler 1.5.5에 공개된 안정성 구성 파일을 사용하면 stable로 간주하고 싶은 클래스를 개발자가 임의 지정 가능   
+ stable로 처리할 클래스의 패키지명을 나열하는 compose_compiler_config.conf 생성
+ Compose 컴파일러가 해당 파일에 정의된 패키지 목록에 대해 recomposition을 건너뛸 수 있도록 build.gradle.kts에서 추가 설정
+ 래퍼 클래스를 수동으로 안 만들고도 특정 클래스를 프로젝트 내에서 전역적으로 stable 지정 가능

| **Strong Skipping Mode**   
불안정한 매개변수를 포함하더라도 Restartable로 분류된 컴포저블 함수에 대해 recomposition 생략을 활성화한다.   
+ stable 매개변수가 있는 컴포저블 함수는 객체 동등성을 사용하여 값 비교하지만 unstable 매개변수는 인스턴스 동등성을 사용하여 비교
+ Strong Skipping Mode 활성화시 모든 컴포저블에 대해 적용되기에 특정 함수를 제외하려면 @NonSkippableComposable 어노테이션을 사용하여 열외 가능

## 실전 질문
Q) List를 매개변수로 받는 컴포저블 함수에서 불필요하게 발생하는 recomposition을 어떻게 최적화하시겠습니까?   
A) 해당 List의 원소가 바뀌지 않는다면 ImmutableList를 사용하거나 UI에 따라 derivedStateOf 등을 사용하여 재구성 범위를 최소화한다.

Q) 앱에서 recomposition 효율성을 개선하기 위해 시도해 본 전략 혹은 Compose 컴파일러 기능 중에 어떤 게 있나요?   
A) derivedStateOf, key, ImmutableList

# Q7 컴포지션(composition)이란 무엇이며 어떻게 생성하나요? 
컴포지션은 컴포저블 함수를 화면에 렌더링할 수 있게 UI 계층 구조로 변환하는 프로세스이다.

| **ComponentActivity.setContent() 함수**   
컴포지션을 생성하는 가장 일반적인 방법은 ComponentActivity 또는 ComposeView에서 제공하는 setContent 함수를 사용하는 것이다.   
setContent()는 컴포지션을 초기화하고 그 안에 표시될 콘텐츠를 정의한다.

setContent()는 컴포저블 함수를 렌더링하고 컴포지션을 시작하는 역할을 하며 Compose UI의 Entry Point가 된다.   
내부적으로는 ComposeView에 의존하여 ComposeView.setContent를 호출하여 컴포지션을 초기화하고 생성한다.

| **XML 레아이웃에 Compose 포함시키기**    
setContent의 내부 원리와 유사하게 XML이 아닌 Kotlin 코드로 직접 ComposeView를 생성하여 사용할 수 있다.

## 실전 질문
Q) ComposeView는 전통적인 View와 Compose UI 시스템을 어떻게 연결하며, 언제 사용되나요? 그리고, ComposeView와 컴포지션의 관계는 어떻게 되나요?   
A) 컴포저블 함수로 작성한 코드를 ComposeView의 setContent 함수를 통해 이를 연결한다. 주로 기존 XML 레이아웃을 사용하던 프로젝트에서 Jetpack Compose로 마이그레이션을 하기 위해 사용한다.   
CompositionView는 컴포지션의 진입점 역할을 수행한다. 

# Q8 XML 기반 프로젝트를 Jetpack Compose로 마이그레이션하는 전략에 대해서 설명해 주세요.
| **점진적 마이그레이션**   
+ **XML에 Compose를 함께 사용하기** : 기존 XML 레이아웃에 Compose 콘텐츠를 포함하려면 ComposeView를 사용한다.
+ **Compose에 XML 포함하기** : 컴포저블 함수 내에 XML 기반 뷰를 포함라며녀 AndroidView를 사용한다.

| **화면별 마이그레이션**   
1. Compose로 마이그레이션하기 쉽거나 마이그레이션하면 즉각적인 이점이 생길만한 화면을 선별
2. 해당 화면의 레이아웃 구조를 Compose를 사용하는 형태로 완전히 재설계
3. Compose의 상태 기반 아키텍처를 활용하여 XML 레이아웃을 컴포저블 함수로 교체

| **점진적 컴포넌트 마이그레이션**   
1. 자주 사용되는 View 기반의 UI 컴포넌트 또는 디자인 시스템의 일부를 선별
2. 선별한 컴포넌트를 컴포저블 함수로 재설계
3. 해당 컴포넌트를 사용중인 XML 레이아웃에서 기존 컴포넌트를 새 컴포저블 컴포넌트로 교체

| **전체 재작성**   
1. Compose에서 테마, 레이아웃 및 커스텀 컴포넌트, 혹은 디자인 시스템 전체를 재개발
2. 전체 UI 스택에서 Compose를 활용하여 XML로 구현했던 앱과 동작 형태를 동일하게 유지
3. Compose 활용에 최적화된 MVI/MVVM 같은 디자인 패턴을 채택하여 앱 전체 아키텍처 재정의 시도

| **라이브러리에 대한 상호 운용성 활용**   
Compose를 지원하지 않는 라이브러리(Exoplayer 등) 사용시 ComposeView/AndroidView 사용

| **마이그레이션 중 테스트 및 모니터링**   
Compose 테스트 라이브러리 및 성능 프로파일링을 수행하여 XML 구현과 비교했을 때 최소 동등에서 향상된 UX 제공 보장 필요

## 실전 질문
Q) XML에서 Compose로 마이그레이션 할 때 기존 View 기반 레이아웃 내에서 부분적으로 컴포저블 함수로 마이그레이션 하는 전략에 대해서 설명해 주시고, 이러한 접근 방식이 가장 유용한 시나리오는 무엇인가요?   
A) ComposeView를 사용하여 점진적으로 마이그레이션을 수행한다. 컴포넌트나 단일 화면 단위로 점진적으로 Compose로 전환하는 것이 안전하다. 대규모 레거시 프로젝트를 점진적으로 현대화할 때 유용하다.

Q) 안드로이드 앱을 화면별로 Jetpack Compose로 마이그레이션 하는 것과 컴포넌트별로 마이그레이션 하는 것의 각 장단점을 경험에 기반하여 말씀해 주세요.    
A) 화면 단위 마이그레이션시 XML과 Compose가 섞이지 않아 보다 깔끔하고 복잡성이 감소하며 테스트가 용이해진다. 그러나 화면 전체를 옮기다보니 작업 규모가 크다.   
컴포넌트 단위 마이그레이션시 보다 점진적으로 적용할 수 있고 하나씩 바꾸기에 UI 일관성 유지가 보다 용이하다. 그러나 컴포넌트마다 ComposeView로 넘기다 보면 보일러플레이트 코드가 많이 늘어나고 복잡도가 올라간다.

### XML과 Jetpack Compose를 동시에 사용하면 앱 (APK/AAB) 사이즈에 영향을 미치나요?
앱 크기에 영향을 미칠 수 있으나 그 효과는 비교적 미미하다.   
Jetpack Compose는 일종의 라이브러리 집합이며 R8 최적화를 사용하는 경우 일반적으로 Compose UI 라이브러리들을 여럿 추가하는 것으로는 최대 약 2MB 정도밖에 늘어나지 않는다.    
메모리 사용량이 아주 민감하다면 문제가 발생할 수 있으나 최신 안드로이드 기기에서는 신경 쓸 정도가 아니다.

# Q9 Compose 성능 테스트를 항상 릴리스 모드(release mode)에서 해야하는 이유는 무엇인가요?
Jetpack Compose 성능을 테스트할 때에는 항상 R8 최적화가 활성화된 릴리스 모드에서 앱을 실행해야 한다.   
디버그 모드에서는 UI 코드에 대한 불필요한 해석, JIT 컴파일, Live Edit Literals와 같은 개발자 도구와 관련된 것들이 추가 오버헤드를 유발하여 최종적인 UX를 똑같이 재현하지 못한다.

| **디버그 모드가 Compose에 미치는 영향**   
Compose는 라이브러리("unbundled") 형태로 제공되어 디버그 앱을 실행할 때 런타임에 의해 해석되고 컴파일된다.   
View 시스템의 경우에는 안드로이드 OS와 함께 번들로 제공되어 미리 컴파일되지만 Compose 라이브러리들은 디버그 모드에 Compose와 관련한 추가적인 Interpret 및 JIT 컴파일 오버헤드를 발생시킨다.   

> 안드로이드 팀에 의하면 전통적인 View와 관련한 코드들은 안드로이드 프레임워크에 이미 통합되어 있기에 빠르게 컴파일되고 최적화된 형태로 돌아간다. 그러나 Compose 라이브러리는 전체 UI 스택을 debuggable한 형태로 실행하기에 디버그 모드에서 추가적인 오버헤드가 발생한다.

| **Live Edit Literals 및 개발자 도구**   
디버그 빌드는 런타임 업데이트를 지원하기 위해 상수를 getter 함수로 대체하는 Live Edit Literals와 같은 개발자 기능을 활성화하고 이는 추가적인 산술 비용 유발 및 최적화를 방해하여 디버그 모드에서 recomposition 및 렌더링을 더 느리게 한다.

| **릴리스 모드에서의 R8 최적화**   
안드로이드 팀에 따르면 R8을 활성화하는 것만으로도 앱 시작 성능이 약 75%, 프레임 렌더링 성능이 약 60% 향상된다고 한다.   
**R8의 최적화 목록**    
+ **람다 그룹화** : 유사한 람다 구현을 그룹화하여 람다 표현식을 최적화하고 메서드 오버헤드를 줄인다. 
+ **소스 정보 생략** : 디버그 및 소스 메타데이터를 제거하여 APK 크기 최소화
+ **상수 폴딩** : 컴파일 시 상수 표현식을 단순화하여 런타임 효율성 향상
+ **인터페이스 호출을 정적 호출로 변환** : 동적 인터페이스 호출을 더 빠른 정적 메서드 호출로 대체하여 실행 속도 크게 향상

| **Baseline Profile가 중요한 이유**   
Baseline Profile은 중요한 Compose 메서드를 사전에 컴파일하여 앱 시작 중 런타임 해석 및 JIT 컴파일을 피한다.   
보통 디버그 빌드는 Baseline Profile이 반영되지 않음

| **실제 테스트 권장 사항**   
성능을 정확하게 테스트하려면 항상 R8 및 Baseline Profiles가 활성화된 릴리스 모드에서 Compose 앱을 테스트해야 한다.

## 실전 질문
Q) R8은 Jetpack Compose 성능 최적화에서 어떤 역할을 하며, 릴리스 빌드에서 어떤 사항을 개선하는지 구체적으로 설명해 주세요   
A) R8은 Tree Shaking(불필요한 코드 제거), 난독화 및 코드 인라인화를 수행하여 Compose 앱의 성능과 크기를 최적화한다. 릴리스 모드에서 디버그 및 소스 메타데이터를 제거하며 유사한 람다를 그룹화하여 메서드 오버헤드를 줄이고 상수 표현식 단순화 및 동적 인터페이스 호출을 정적 메서드 호출로 대체하는 등으로 앱 성능과 크기를 개선한다.

# Q10 Jetpack Compose에서 자주 사용하시는 Kotlin 관용구(idioms)에 대해서 말씀해 주세요.
| **기본 매개변수**   
| **고차 함수 및 람다 표현식**   
Compose는 함수를 매개변수로 받는 고차 함수를 광범위하게 사용한다.   
별도의 함수를 정의하는 대신 람다 표현식으로 동작을 인라인으로 정의하여 코드 가독성과 유지보수성을 확보할 수 있다.

| **후행 람다**   
Kotlin은 람다 표현식을 함수의 마지막 매개 변수로 전다랗면 람다의 실행체를 함수 바깥으로 뺄 수 있도록 허용하여 코드 간결성을 높인다.

| **스코프 및 수신 객체**   
Compose API는 종종 스코프가 포함된 람다 함수를 제공하여 특정 컨텍스트 내에서만 특정 Modifier나 프로퍼티에 접근할 수 있도록 한다.

| **위임 속성**   
```kotlin
var count by remember { mutableStateOf(0) }
```

| **데이터 클래스 구조 분해**   
| **싱글톤 객체**   
| **type-safe 빌더 및 DSL**   
| **Kotlin 코루틴**   
`rememberCoroutineScope()`라는 컴포지션에 연결된 코루틴 스코프를 사용하고 이 코루틴은 recomposition이 발생해도 진행하고 있는 작업을 유지한다.

## 실전 질문
Q) 컴포저블 함수를 구조화하기 위해 후행 람다나 고차 함수를 자주 사용하는데 이러한 Kotlin 관용구가 Compose API에서 사용되는 예시를 들어주세요.   
A) Column이나 Row의 내부 content에서 후행 람다를 사용하고 Button의 onClick에서 대표적으로 고차 함수를 사용한다.