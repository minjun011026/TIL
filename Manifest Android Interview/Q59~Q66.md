# Q59 장기적으로 실행되는 백그라운드 작업을 어떻게 관리하나요?
| **조건부 작업에 적합한 WorkManager**   
앱이 닫히거나 기기 재부팅 후에도 실행되어야 하는 작업의 경우 **WorkManager**가 공식적으로 권장되는 솔루션이다.   
ex) 로그 업로드, 데이터 동기화, 비디오와 같은 영상 파일 업로드 등

| **오랜 작업에 적합한 Service**   
음악 재생이나 위치추적같이 지속적이고 오랜 실행이 필요한 작업에는 **Service**가 이상적이다.   
Service는 UI와 독립적으로 실행되며 앱이 백그라운드에 있을 때도 계속 실행 가능   
작업이 Notification과 함께 사용자가 인지할 수 있는 상황에서 실행되어야 할 경우 **Foreground Service**를 사용한다.

| **Kotlin Coroutines 및 Dispatchers 사용하기**   
앱 생명주기에 연결된 작업의 경우 코루틴이 적합하다.   
+ `Dispatchers.IO` : 무거운 작업 오프로드   
+ `Dispatchers.Default` : CPU 집약적인 계산

CPU 집약적인 작업이란?   
-> 연산 능력을 요구하며 사용 가능한 CPU 코어 수만큼만 스레드를 생성하는 작업으로 암호화, 이미지 처리, 비디오 인코딩, 데이터 분석과 같은 작업이 포함된다. 이 작업은 전적으로 CPU에 의존하여 사용 가능한 코어 수보다 많은 스레드를 추가하면 성능 향상보다는 스레드 경합이 발생하는 경우가 많다.

| **시스템 수준 작업에 적합한 JobScheduler**   
작업이 기기 전체 작업과 관련되고 특정 조건(ex. 충전 중에만 실행)이 필요할 경우 JobScheduler를 사용할 수 있다.   
즉시 실행이 필요하지 않은 작업에 적합하다.(WorkManager는 내부적으로 JobScheduler 등을 활용하므로 일반적인 상황에서는 WorkManager 사용)

## 실전 질문
Q) 안드로이드 앱에서 백엔드 서버로부터 대용량 파일(수백 MB)을 다운로드하는 기능을 구현해야 합니다. 다운로드는 앱이 닫혀도 계속되어야 하며, 성능 및 네트워크 조건 측면에서 효율적이어야 합니다. WorkManager, Foreground Service, JobScheduler 중 어떤 것을 선택하여 구현하시겠나요?   
A) WorkManager를 사용할 것이다. 대용량 파일을 와이파이가 아닌 데이터로 다운로드할 경우 데이터 소모 등의 문제가 있는데 이런 문제를 제약 조건으로 제한할 수 있다. 또한 앱종료/기기 재부팅 후에도 실행을 보장할 수 있다.    
그러나 사용자가 다운로드 상황을 인지할 수 있도록 하고 시스템의 메모리 회수 대상에서 우선순위를 낮추기 위해 WorkManager를 Foreground Service로 올리는 `setForegroundAsync()`를 사용하는 것이 가장 바람직하다고 생각한다.

# Q60 Json 형식을 객체로 어떻게 직렬화 하나요?
| **직렬화와 역직렬화란?**   
+ 직렬화(Serialization) : 객체나 데이터 구조를 나중에 쉽게 사용할 수 있는 형식으로 변환하는 프로세스로 안드로이드와 백엔드 통신에서 종종 객체를 JSON 문자열이나 유사한 구조화된 형식으로 변환하는 걸 의미한다.
+ 역직렬화(Deserialization) : 직렬화된 데이터(JSON 문자열 등)을 가져와 애플리케이션에서 작업할 수 있는 메모리 내 객체로 다시 재구성하는 역 프로세스

| **kotlinx.serialization**   
+ kotlinx.serialization는 Kotlin과 직접적으로 통합되어 Kotlin의 언어적 기능을 활용하도록 설계됨
+ 어노테이션을 사용해 직렬화 동작을 정의하고 JSON뿐만이 아닌 ProtoBuf와 같은 다른 형식과도 원활하게 작동
+ Kotlin 컴파일러 플러그인을 사용하여 Kotlin 객체를 JSON으로 직렬화하고 다시 Kotlin으로 역직렬화하는 타입 안정성 제공
+ 내부적으로 리플렉션을 사용하지 않은 메커니즘 제공

| **Moshi**   
+ Gson과 달리 Kotlin의 nullable 및 기본 매개변수를 기본적으로 제공
+ 리플렉션 기반 동작 방식과 컴파일 타임에 코드를 생성(codegen)하는 방식, 2가지가 있음
  + 리플렉션 기반 Moshi : Java 리플렉션을 사용하여 런타임에 동적으로 JSON 어댑터를 생성하므로 추가 설정이 없어 사용법이 간단하지만 반드시 런타임 오버헤드가 발생
  + 코드 생성 기반 Moshi : 어노테이션 프로세스 기법을 통해 컴파일 타임에 JSON 어댑터를 생성하여 더 빠른 런타임 성능과 컴파일 타임 오류 검사 제공

| **Gson**   
+ Google에서 개발한 JSON 라이브러리
+ Java 객체 -> JSON, JSON -> Java 객체 가능

Gson 대신 kotlinx.serialization/Moshi 사용해야 하는 이유
1. 더 나은 Kotlin 지원 : Gson은 Java용으로 설계되어 Kotlin 기능(기본 매개변수, var/val 차이, nullable)을 다른 2방법만큼 자연스럽게 처리 X
2. 성능 및 효율성 : kotlinx.serialization 및 Moshi(codegen)는 런타임 리플렉션에 크게 의존하는 Gson보다 빠르고 메모리 효율적
3. 멀티플랫폼 호환성 : kotlinx.serialization는 KMP 를 완벽하게 지원, Moshi/Gson은 JVM 위에서 동작하도록 설계되어 크로스 플랫폼에는 적절하지 않음
4. 컴파일 타임 안정성 : 컴파일 타임에 필요한 코드를 생성하는 kotlinx.serialization 및 Moshi는 컴파일 타임에 대부분의 오류를 감지하여 런타임 크래시를 줄이나 Gson는 종종 런타임 오류로 크래시 발생

## 실전 질문
Q) API의 JSON 응답이 주어졌을 때, 이를 Kotlin 데이터 클래스로 어떻게 역직렬화하시겠습니까? Kotlin을 사용하는 프로젝트에서 어떤 라이브러리를 선택할 것이고, 그 이유는 무엇인가요?   
A) kotlinx.serialization를 사용한다. 기본적으로 리플렉션을 사용하지 않아 성능적으로도 이점이 있고 nullable 및 기본 값을 지원하는 등 Kotlin과 호환성이 좋다. 또한 다른 라이브러리들에 비해 kotlinx.serialization가 대중적인만큼 팀원들과의 협업에도 적절하다고 판단한다. 

Q) Kotlin 데이터 클래스에 정의되지 않은 누락되거나 추가적인 필드가 있는 JSON 문자열을 역직렬화해야 하는 경우 어떻게 처리하실 건가요?    
A) kotlinx.serialization 기준으로 추가적인 필드가 있는 경우 JSON 구성시 `ignoreUnknownKeys = true` 옵션을 추가한다. 만약 누락된 값이 있다면 데이터 클래스 선언시 기본값을 부여한다. 만약 타입이 다른 경우에는 `coerceInputValues = true` 옵션으로 해당 필드를 디폴트 값으로 치환한다.

# Q61 원격 데이터를 가져오기 위해 네트워크 요청을 어떻게 처리하며, 효율성과 신뢰성을 위해 어떤 라이브러리나 기술을 사용하나요?  
| **Retrofit을 사용한 네트워크 요청**   
Retrofit은 HTTP 요청을 깔끔하고 type-safe한 API 인터페이스로 추상화한다.    
**백엔드 데이터 가져오는 단계**   
1. API 인터페이스 정의 : 어노테이션을 사용하여 API 엔드포인트와 HTTP 메서드를 선언한다.
2. Retrofit 인스턴스 설정 : 베이스 URL과 JSON 직렬화를 위해 ConverterFactory를 통해 Retrofit을 구성한다.
3. 네트워크 호출하기 : 코루틴을 사용하여 API를 비동기적으로 호출한다.

| **OkHttp와 Retrofit을 통합하기**   
Retrofit은 내부적으로 OkHttp를 HTTP 클라이언트로 사용한다.   
Interceptor를 추가(`addInterceptor()`)하여 로깅, 인증 또는 캐싱과 같은 OkHttp의 동작을 커스텀할 수 있다.

## 실전 질문
Q) 앱에서 동시에 여러 API 요청을 수행하고 UI를 업데이트하기 전에 결과를 결합해야 한다고 가정해 봅시다. Retrofit과 코루틴을 사용하여 이를 효율적으로 구현하려면 어떻게 해야 하나요?   
A) 각각의 요청을 코루틴 `async` 빌더를 사용하여 수행하고 그 결과를 `await`이나 `awaitAll`로 대기한다. 이후 각 값이 모두 반환되면 이를 결합하여 UI를 업데이트한다.

Q) API 응답 실패 시 어떻게 처리하고, 재시도 메커니즘은 어떻게 구현하나요?   
A) 에러의 성격에 따라 다르게 처리해야 한다. 예를 들어 네트워크 에러면 설정 확인 UI를 띄우고 401(Unauthorized)과 같은 실패는 토큰 갱신 로직을 수행하는 등 각각의 상황에 맞게 처리한다.   
서버 에러(5xx)의 경우 재시도 메커니즘을 수행하는데 Exponential Backoff 전략을 사용할 수 있다. OkHttp의 인터셉터를 활용해 재시도 로직을 관리 가능하다.

### OkHttp Authenticator 및 Interceptor를 사용하여 OAuth 토큰 갱신하기
OAuth로 보호되는 API로 작업할 때 토큰 만료 및 갱신 시나리오 처리를 하는 것이 일반적이다. OkHttp는 토큰을 가로채고 새로 고치는 2가지 주요 메커니즘인 Authenticator와 Interceptor를 제공한다.

| **OkHttp Authenticator**   
+ 서버가 401(Unauthorized) 상태 코드 응답시 Authenticator가 호출되어 업데이트된 인증 자격 증명이 포함된 새 요청을 제공한다.
+ OkHttpClient 생성시 `.authenticator()`로 설정 필요

| **OkHttp Interceptor 사용하기**   
+ Authenticator와 달리 Interceptor는 요청 또는 응답이 처리되기 전에 가로채서 수정 가능
+ OkHttpClient 생성시 `.addInterceptor()` 설정 필요

### Retrofit CallAdapter란?
Retrofit의 CallAdapter는 개발자가 Retrofit API 메서드의 반환 타입을 사용자 정의할 수 있도록 하는 추상화 API이다.   
기본적으로 Retrofit API 메서드는 HTTP 요청을 나타내는 `Call<T>` 객체 반환 -> CallAdapter 사용시 LiveData, Flow, RxJava 또는 커스텀 타입으로 변환 가능   

| **CallAdapter 작동 방식**   
Retrofit은 CallAdapter 인스턴스 생성을 위해 `CallAdaptor.Factory` 사용   
CallAdaptor는 런타임에 `Call<T>`객체를 원하는 타입으로 변환하는 역할을 수행   

| **Retrofit의 기본 CallAdapter**   
기본적으로 Retrofit에는 `Call<T>` 객체를 직접 반환하는 CallAdapter가 포함되어 있어 다른 타입을 원하면 적절한 라이브러리나 커스텀 CallAdapter 작성 필요

| **Retrofit과 Coroutine CallAdapter 사용하기**   
Kotlin Coroutines Adapter를 사용시 Retrofit API 인터페이스에서 suspend 함수 사용 가능   
이 경우 `Call<T>` 에서 `T`를 반환하는 suspend 함수로 변환된다.

# Q62 대규모 데이터 셋을 효율적으로 로드하는 데 왜 페이징 기법이 필요하고, RecyclerView로 구현해 본 경험이 있나요?
+ 데이터를 더 작은 페이지로 로드하면 메모리 사용량이 크게 줄어들어 잠재적인 메모리 부족 문제를 방지할 수 있다.
+ 한 번에 많은 데이터를 로드하는 것이 아닌 현재 화면에 보여지는데 필요한 데이터만 가져와 렌더링하므로 초기 로드 시간이 단축된다.
+ 더 필요한 데이터는 필요할 때만 요청되므로 네트워크 사용량이 최소화되어 특히 대역폭이 제한된 시나리오에서 리소스를 효율적으로 사용 가능하다.

| **페이징 시스템 직접 구현**   
1. RecyclerView.Adapter 및 ViewHolder 생성
   + Adapter는 데이터 소스를 처리하고 ViewHolder는 데이터 셋의 아이템이 개별적으로 렌더링 되는 방식을 정의한다.
2. RecyclerView에 addOnScrollListener 추가
   + `addOnScrollListener`를 구현하여 스크롤 상태를 트래킹한다. 이를 통해 사용자가 현재 화면에서 마지막으로 보이는 항목까지 스크롤한 경우를 감지할 수 있다.   
   화면에서 마지막으로 보이는 항목이 데이터 셋 끝에 가까워지면 네트워크/DB에서 다음 데이터 셋에 대한 로드를 트리거한다. 더 부드러운 로딩을 원한다면 끝에 도달하기 전에 미리 가져오기 위한 임계값을 사용한다.
3. RecyclerView.Adapter에 새 데이터셋 추가
   + 새로 검색된 데이터 셋을 RecyclerView.Adapter의 기존 데이터에 추가한다. 

## 실전 질문
Q) 앱이 1000개의 데이터 셋을 가져와 리스트에 표시해야 한다고 가정해 봅시다. 원활한 스크롤을 보장하고 메모리 사용량을 줄이기 위해 효율적인 페이징 시스템을 어떻게 구현하시겠습니까?   
A) Jetpack Paging 라이브러리를 사용한다. 먼저 데이터를 가져오는 로직을 작성한 PagingSource를 정의한다. 이후 Pager의 pageSize, prefetchDistance를 설정한 다음 PagingData를 생성한다. 이때 `cachedIn(viewModelScoep)` 설정을 활용하여 페이지네이션된 데이터를 캐싱해 configure change 시 데이터를 다시 부르지 않도록 한다.   
이후 PagingDataAdapter를 RecylcerView에 연결한다. 이때 DiffUtil을 통해 불필요한 리렌더링을 방지해준다. compose라면 `collectAsLazyPagingItems`, 보다 원활한 스크롤을 보장하고자 한다면 데이터가 아직 로딩되지 않은 영역엔 placeholder를 활용한다.

Q) RecyclerView로 직접 페이징 시스템을 구현할 때 발생할 수 있는 문제는 무엇이며, 원활한 사용자 경험을 제공하기 위해 어떻게 해결할 수 있나요?   
A) 사용자가 빠르게 스크롤하는 등으로 리스트 하단 도달 이벤트가 짧은 시간 동안 여러번 발생 가능하다. 이러한 상황에서는 다음 페이지 로딩중 여부를 상태 변수로 두어 추가 요청을 무시하도록 한다.   
UI 깜빡임 또는 스크롤이 튀는 현상이 발생할 수 있다. 이때 DiffUtil과 ListAdapter를 활용하여 방지할 수 있다.
마지막으로 데이터 로딩 실패시 재시도 로직 또는 에러 표시 처리를 해주어야한다.

# Q63 네트워크에서 이미지를 어떻게 가져오고 렌더링하나요?
| **Glide**   
Glide는 자동으로 이미지를 캐시하여 네트워크 호출을 최적화하고 성능을 향상시킨다.

| **Coil**   
Coil은 Kotlin Multiplatform으로 설계된 100% Kotlin 기반의 이미지 로딩 라이브러리로 내부적으로 Coroutines를 활용하고 Jetpack Compose와 같은 최신 기능을 지원한다.   
Coil은 내부적으로 OkHttp 및 Coroutines와 같이 안드로이드 프로젝트에서 이미 널리 사용되는 라이브러리를 사용하기에 기존 프로젝트에 원활한 통합이 가능하다.

아래는 내가 Glide와 Coil을 비교했던 글이다.
https://velog.io/@couch_potato/Android-Coil-vs-Glide-in-Compose

| **Fresco**   
Fresco는 큰 이미지 처리, 점진적 렌더링 및 고급 캐싱 전략에 매우 효율적이어서 메모리 제약이 있는 애플리케이션에 특히 유용하다.   
안드로이드 4.x 이하에서 이미지를 특수 메모리 영역에 할당하여 성능을 높였으나 현대 사회에서 안드로이드 4.x 이하 디바이스 기기는 거의 찾기 힘듦

## 실전 질문
Q) 앱이 백엔드 서버에서 고해상도 이미지를 로드하여 RecyclerView에서 부드러운 스크롤을 제공해야 합니다. 어떤 이미지 로딩 라이브러리를 선택할 것이고, UI 지연을 방지하기 위해 성능을 어떻게 최적화하시겠습니까?   
A) Coil을 사용한다. Coil은 OkHttp와 Coroutines을 사용하므로 기존 프로젝트와 통합이 원활하고 비동기 처리가 수월하다. 성능을 최적화하기 위해 `size()`로 화면에 보여질 크기에 맞게 다운샘플링을 수행한다. 또한 해당 이미지가 투명도가 필요없다면 RGB_565로 설정을 변경하면 메모리 사용량을 줄일 수 있다.    
또한 이후 동일한 이미지를 다시 로드할 경우가 많다면 메모리캐시/디스크캐시를 활용한다. 

# Q64 로컬 디바이스에 데이터를 저장하고 복원하는 방법에 대해서 설명해주세요.
| **SharedPreferences**   
SharedPreferences는 앱 내 설정이나 사용자 환경 설정과 같은 가벼운 값에 가장 적합한 키-값 형태의 데이터 저장 메커니즘이다.   
primitive 타입을 저장하고 앱 재시작 시에도 유지할 수 있다.   
유의해야할 점은 SharedPreferences는 동기적으로 작동하여 메인 스레드를 차단하는 문제가 있고 비동기 처리 함수 등을 지원하는 DataStore의 등장으로 최근에는 덜 선호된다.

| **DataStore**   
+ SharedPreferences를 대체하는 보다 현대적이고 효율적인 방법
+ 키-값 저장을 위한 PreferencesDataStore
+ 구조화된 객체 값 데이터를 위한 ProtoDataStore
+ 비동기식으로 메인 스레드 차단 문제 방지

| **Room Database**   
+ 구조화되고 관계형 데이터 처리를 위해 설계된 SQLite를 추상화한 솔루션
+ 어노테이션, 컴파일 타임 검사, 반응형 프로그래밍을 위한 LiveData/Flow 지원을 통한 DB 관리 단순화

| **File Storage**   
+ 바이너리 또는 커스텀 데이터의 경우 안드로이드는 내부/외부 저장소에 파일을 저장할 수 있도록 한다.
+ 내부 저장소는 앱 간 접근 불가능, 외부 저장소는 다른 앱과 공유 가능

## 실전 질문
Q) 오프라인 접근을 위해 네트워크 API에서 받은 대용량 JSON 응답을 저장해야 하는 시나리오에서 어떤 로컬 저장 메커니즘을 사용할 것이고, 그 이유는 무엇인가요?    
A) Room 사용, 대용량 JSON 응답을 파일로 저장할 경우 앱을 켤 때마다 큰 크기의 텍스트를 메모리에 올려서 객체로 파싱해야하여 적합하지 않다. 또한 DataStore 및 SharedPreferences는 소규모 설정 값 저장에 적합하다.   
특히 이후 JSON 응답에서 전체가 아닌 일부만 사용할 경우에도 필요한 데이터만 부분적으로 쿼리할 수 있어 효율적이다.

# Q65 오프라인 우선(offline‑first) 아키텍처를 어떻게 설계하실 건가요?
| **오프라인 우선 아키텍처의 핵심 개념**   
1. 로컬 데이터 지속성 : 앱이 오프라인 상태에서도 데이터에 접근하고 업데이트할 수 있는 Room DB와 같은 솔루션을 사용한다.
2. 데이터 동기화 : 로컬 데이터와 원격 데이터 간의 동기화는 일관성을 보장한다. WorkManager는 네트워크 연결과 같은 조건이 충족될 때 지연된 동기화 작업이 실행되도록 하며 실패한 작업을 자동으로 재시도하여 데이터 무결성을 보장한다.
3. Cache 및 Fetch 정책
   + 캐싱 데이터 읽기 : 앱이 먼저 로컬 저장소에서 데이터를 가져오고 필요할 때만 네트워크에 새로운 데이터를 요청한다.
   + 캐싱 데이터 쓰기 : 업데이트가 로컬에 기록되고 백그라운드에서 서버와 동기화된다.
4. 충돌 해결 : 로컬 소스와 원격 소스 간 동기화 과정에서의 충돌 해결 전략 구현 필요
   + 최신 데이터 우선
   + 사용자 정의 : 수동으로 충돌 해결 or 도메인별 규칙 적용

## 실전 질문
Q) 네트워크가 자주 끊기는 국가 및 지역에서도 원활한 사용자 경험을 보장하기 위해 오프라인 우선 기능을 어떻게 설계하시겠습니까?   
A) WorkManager를 사용하여 백그라운드에서 네트워크 연결이 되었을 때마다 데이터를 가져온다. 이때 가져온 데이터는 로컬 데이터에 먼저 저장한다. 이후 네트워크가 끊기더라도 캐싱된 데이터를 표시하고 사용자의 쓰기 작업은 로컬에 먼저 반영하고 이후 네트워크에 연결되었을 때 동기화되지 않은 데이터만 백그라운드에서 동기화해주어 원활한 사용자 경험을 보장한다.

Q) 로컬 Room 데이터베이스 변경 사항을 백엔드 서버의 최신 데이터와 동기화하는 데 어떤 전략을 사용할 것이고, 로컬 및 백엔드 데이터가 모두 변경되었을 때 충돌을 어떻게 해결하시겠습니까?   
A) 동기화 여부를 저장하는 플래그 변수를 추가하고 WorkManager를 사용하여 백그라운드 동기화를 수행하여 플래그 변수의 값을 수정하는 방식을 사용한다. 만약 데이터 충돌시에는 최신 데이터 우선 전략을 사용하여 충돌 문제를 해결한다.

# Q66 초기 데이터 로딩을 위한 작업을 Compose의 LaunchedEffect와 ViewModel.init() 중 어디에서 하는 것이 가장 이상적인가요?
초기 데이터 로딩을 하는 방식으로는 `ViewModel.init()`과 `LaunchedEffect`가 있다.    

+ `ViewModel.init()` : Jetpack Compose UI를 애플리케이션 상태 또는 데이터의 시각적 표현으로 간주한다면 앱에 무엇을 해야할지 지시하기 위해 UI에 의존하는 것은 설계 결함이므로 `ViewModel.init()`을 사용해야 한다.
+ `LaunchedEffect` : `ViewModel.init()`에만 의존시 특정 동작이 트리거되는 시점에 대한 제어와 유닛 테스트가 어려워진다. ViewModel에선 이벤트 기반 흐름을 관찰하여 트리거되고 지연 초기화될 수 있는 독립적인 함수 정의가 더 낫다.

-> Google의 Android Toolkit 팀의 Ian Lake는 두 방식 모두 안티패턴이라 지적 -> **cold flows**

## 실전 질문
Q) ViewModel.init() 또는 Jetpack Compose의 LaunchedEffect에서 초기 데이터를 로드하는 것의 장단점은 무엇이며, 언제 어떤 접근 방식을 사용하시나요? 만약 다른 접근법을 선호한다면 어떤 것이 있나요?   
A) ViewModel.init()의 경우 일반적으로 ViewModel의 생명주기가 Composable보다 길어 configure change에서도 데이터 로딩이 중단되거나 중복 호출되지 않는 장점이 있다. 그러나 특정 동작이 트리거 되는 시점에 대한 제어가 어렵다. 예를 들어 테스트에서 성공, 실패, 지연 등을 테스트하려고 해도 이미 init에서 요청이 날아가므로 제어가 어렵다는 단점이 있다.      
LaunchedEffect는 특정 내비게이션 인자나 UI 상태에 따라 데이터를 불러와야 할 때 구현이 매우 직관적이라는 장점이 있다. 그러나 configure change 시 ViewModel의 데이터는 살아있는데도 LaunchedEffect가 재실행되어 불필요한 재호출이 발생할 수 있다는 단점이 있다.   
주로 ViewModel.init()은 앱의 전반적인 상태를 로드할 때, 화면 전환이 잦아도 데이터가 새로고침 되지 않아야할 때 사용한다. LaunchedEffect는 화면 진입 시점에서의 상태마다 다른 정보를 가져오거나 상태마다 매번 다른 정보를 가져와야할 때 사용한다.   
SharingStarted.WhileSubscribed을 이용한 반응형 지연 로딩 방식을 사용한다. 이 방식을 사용시 실제 데이터가 요구되는 시점에 로딩을 시작하며 ViewModel에서 Flow를 관리하여 configure change에서도 재호출 등의 문제를 방지할 수 있고 테스트시에도 init시 아무일도 일어나지 않아 원하는 시점에 `collect`로 데이터 호출을 트리거할 수 있다.

Q) ViewModel.init() 또는 LaunchedEffect와 비교할 때 콜드 플로우를 사용한 지연 관찰은 초기 데이터를 로드할 때 효율성을 어떻게 개선하나요? 해당 접근 방식이 유익한 시나리오 예를 들어주세요.   
A) ViewModel.init()과 비교했을 때 init 방식은 사용자가 해당 화면을 볼지 안볼지 모르는 상황에서도 일단 뷰모델이 생성되는 순간 네트워크 호출이 일어난다. 그러나 콜드 플로우 방식은 collect, 구독자가 나타나기 전까지는 실행되지 않는다. 즉 실제 화면이 사용자 눈에 보이고 데이터가 필요한 순간에만 리소스를 사용한다. 또한 init에서 시작된 코루틴은 뷰모델이 죽기 전이나 수동 취소 전까지 리소스를 점유하나 콜드플로우는 UI가 백그라운드로 가거나 화면을 떠나면 스스로 로딩을 멈출 수 있다.         
LaunchedEffect와 비교하면 configure change 시의 재호출 방지로 효율성을 개선한다.   
이 방식은 탭 아키텍처나 다중 레이어 화면처럼 즉시 데이터를 로드할 필요가 없는 상황에서 유익하다.

