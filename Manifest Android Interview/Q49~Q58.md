# Q49 AppCompat 라이브러리는 무엇인가요?
Android Jetpack 제품군의 일부로 하위 안드로이드 버전과의 하위 호환성을 보장하면서 최신 기능을 앱에 사용할 수 있게 하는 라이브러리   

| **주요 기능**   
+ UI 컴포넌트 하위 호환성 : FragmentActivity를 확장하고 하위 버전의 안드로이드와의 호환성을 보장하는 AppCompatActivity와 같은 최신 UI 컴포넌트 를 제공한다. 이를 통해 개발자는 하위 안드로이드 버전을 실행하는 기기에서 액션바와 같은 기능 사용 가능
+ Material Design 지원 : AppCompat을 사용하면 개발자는 하위 안드로이드 버전을 실행하는 기기에 Material Design 원칙 통합 가능, 여기에는 AppCompatButton, AppCompatTextView 등 기기의 API 레벨에 따라 모양과 동작을 자동으로 조정하는 위젯이 제공된다.
+ 테마 및 스타일링 지원 : AppCompat을 사용하면 Theme.AppCompat과 같은 테마를 사용하여 모든 API 레벨에서 일관된 UI를 보장할 수 있다. 이러한 테마는 Vector Drawable 지원과 같은 최신 스타일링 기능을 하위 안드로이드 버전에 제공한다.
+ 동적 기능 지원 : AppCompat 라이브러리는 동적 리소스 로딩 및 Vector Drawable 지원을 제공하여 하위 호환성을 유지하면서 최신 디자인 요소를 효율적으로 구현하기 쉽게 만듬

| **AppCompat 사용하는 이유**   
최신 안드로이드 기능과 UI 컴포넌트가 지원되는 모든 API 레벨에서 일관되게 작동하도록 보장하고자 사용   
개발자가 최신 기능이 풍부한 앱을 구축하는데 집중하도록 하며 하위 버전의 안드로이드 기기에서 호환성을 유지하기 위한 복잡성을 줄인다.

## 실전 질문
Q) AppCompat 라이브러리는 하위 안드로이드 버전에서 Material Design 지원을 어떻게 가능하게 하며, 이와 같은 동작을 기반으로 하는 주요 UI 컴포넌트에는 무엇이 있나요?   
A) AppCompat 라이브러리는 Layout Inflation 가로채기와 테마 속성 백포팅 메커니즘을 통해 지원하게 한다. 이를 기반으로 하는 UI 컴포넌트는 AppCompatButton, AppCompatTextView 등이 있다.

# Q50 Material Design Components (MDC)란 무엇인가요?
Material Design Components는 Google의 Material Design 가이드라인을 기반으로 하는 커스텀 간으한 UI 위젯 및 컴포넌트 집합이다.   

| **주요 특징**   
1. **Material Theming** : MDC는 Material Theming을 통해 테마 설정을 지원하여 개발자가 타이포그래피, 모양 및 색상을 전역적으로 또는 컴포넌트 수준에서 커스텀할 수 있도록 한다.
2. **미리 빌드된 UI 컴포넌트** : MDC는 버튼, 카드 등 즉시 사용가능한 접근성, 성능 및 반응성에 최적화된 광범위한 UI 컴포넌트 제공
3. **애니메이션 지원** : Material Design은 모션 및 전환을 강조, MDC에는 공유 요소 전환(shared element transition) 등 애니메이션에 대한 내장 지원이 포함되어 있음
4. **다크 모드 지원** : 해당 라이브러리에는 다크 모드를 쉽게 구현할 수 있는 API가 포함되어 있음
5. **접근성** : MDC는 더 큰 터치 대상, 접근성을 위한 sementic 레이블 및 적절한 포커스 관리와 같은 기능을 제공하여 접근성 표준을 준수하며 모든 사용자를 위한 포괄적인 Ui를 보장한다.

## 실전 질문
Q) MDC의 Material Theming은 앱 전체에서 디자인 일관성을 유지하는 데 어떻게 도움이 되나요?   
A) 테마 설정을 지원하여 타이포그래피, 색상, 모양 등에 대해 Semantic Attribute를 제공하여 일관성을 유지한다. 개발자가 전역적으로 관리할 수 있고 또한 컴포넌트 수준에서 커스텀을 가능하게 한다.   
예를 들어 단순 `colorRed`는 값 중심이지만 `onPrimary`와 같이 의미 중심으로 일관성 유지를 용이하게 한다.

참고   
+ Shared Element Translation(공유 요소 전환) : 서로 다른 두 화면 사이에서 특정 뷰가 연속적으로 이어지는 것처럼 보이는 애니메이션 기법

# Q51 ViewBinding를 사용하면 어떤 장점이 있나요?
ViewBinding은 레이아웃의 뷰와 상호작용하는 프로세스를 단순화하기 위해 안드로이드에서 도입된 기능이다.    
수동으로 `findViewById()`를 호출 안해도 되고 뷰에 접근하는 type-safe 방식을 제공하여 보일러 플레이트 코드와 잠재적 런타임 오류를 최소화 한다.

| **작동 방식**   
ViewBinding을 활성화시 안드로이드는 각 XMl 레이아웃 파일에 대한 바인딩 클래스를 생성한다.   
바인딩 클래스는 레이아웃의 모든 뷰에 대한 참조가 포함되어 있어 캐스팅하거나 `findViewById()`를 호출할 필요없이 직접 접근가능하다.

| **장점**   
+ **타입 안정성** : 캐스팅할 필요없이 뷰에 직접 접근하여 타입 불일치로 인한 런타임 오류를 제거합니다.
+ **더 깔끔한 코드** : `findViewById()`를 호출할 필요가 없어지고 보일러 플레이트 코드가 줄어든다.
+ **Null 안정성** : nullable 타입의 뷰를 자동으로 처리하여 선택적 UI 컴포넌트와 상호작용할 때 더 안전한 코드를 보장한다.
+ **성능** : DataBinding과 달리 ViewBiding은 바인딩 표현식이나 추가 XML 파싱을 사용하지 않아 런타임 오버헤드가 최소화된다.

| **DataBinding과 비교**   
DataBinding은 바인딩 표현식 및 양방향 데이터 바인딩과 같은 더 많은 기능을 제공하지만 더 복잡하고 런타임 오버헤드를 유발한다.   
반면에 ViewBinding은 순수하게 뷰 상호작용 단순화에 중점을 두어 성능 면에서 더 가볍다.   
LiveData나 Flow 등을 바인딩하여 데이터를 직접적으로 결합하는 등과 같은 기능이 필요하지 않은 경우 이상적이다.

## 실전 질문
Q) ViewBinding은 findViewById()와 비교하여 타입 안전성과 null 안전성을 어떻게 개선하며, 해당 접근 방식의 이점은 무엇인가요?   
A) 컴파일 타임에 각 XML 레이아웃에 대한 바인딩 클래스를 생성함으로서 안정성을 개선한다. 바인딩 클래스 내의 필드는 XML에 정의된 View의 타입을 정확히 알고 생성하여 타입 안정성을 개선하고 ViewBinding은 레이아웃에 실제로 존재하는 뷰에 대해서만 참조를 생성하기에 예를 들어 가로모드에만 있는 뷰라면 해당 필드를 nullable로 표시하여 개발자가 컴파일 단계에서 null 체크를 하도록 강제함으로서 null 안정성을 개선하다.   
이러한 접근 방식을 통해 런타임 에러를 컴파일 타임 에러로 끌어올려 앱의 안정성을 높인다.

# Q52 DataBinding의 동작 원리에 대해서 설명해주세요.
DataBinding은 XML 레이아웃의 UI 컴포넌트를 앱의 데이터 소스에 직접 바인딩할 수 있는 안드로이드 라이브러리이다.   

| **특징**   
1. **양방향 데이터 바인딩** : UI 와 기본 데이터 모델 간의 데이터 자동 동기화를 가능하게 한다. 
2. **바인딩 표현식** : 문자열 연결 또는 조건문과 같은 간단한 로직을 XML에서 직접 사용 가능
```xml
<TextView 
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@{user.age > 18 ? `성인` : `미성년자`}"
        android:visibility="@{user.isAdmin ? View.VISIBLE : View.GONE}" />
```   
3. **생명주기 인식** : 생명주기가 Activity/Fragment가 활성 상태일 떄 같은 적절한 상태일 때만 UI를 자동으로 업데이트한다.

| **장점**   
+ 보일러 플레이트 코드 감소
+ 실시간 UI 업데이트
+ 선언적 UI
+ 테스트 용이성 향상

| **단점**   
+ 성능 오버헤드 : ViewBinding과 같은 더 가벼운 솔루션에 비해 더 많은 런타임 오버헤드 발생
+ 복잡성 : 작거나 간단한 프로젝트에는 불필요한 복잡성 유발 가능
+ 학습 곡선 : 바인딩 표현식 및 생명주기 관리에 대한 러닝 커브가 요구된다.

## 실전 질문
Q) DataBinding과 ViewBinding의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 선택하는 것이 좋을까요?   
A) ViewBinding은 별도의 처리없이 해당 레이아웃의 바인딩 클래스를 생성하지만 DataBinding은 어노테이션 처리로 빌드 시간이 더 소요된다. 또한 <layout/>이라는 별도의 태그로 반드시 감싸야 하며 ViewBinding과 달리 양방향 바인딩을 지원한다.   
MVVM 패턴에서 UI 로직 최소화/보일러 플레이트 코드를 줄이고자 한다면 DataBinding, 빌드 성능을 중요시하고 단순한 화면이라면 ViewBinding을 사용하는 것이 좋다.

Q) MVVM 아키텍처에서 DataBinding은 어떤 역할을 하며, 안드로이드 개발에서 UI 로직과 비즈니스 로직을 분리하는 데 어떻게 활용할 수 있나요?   
A) MVVM 아키텍처에서 DataBinding은 View와 ViewModel 사이의 Binding을 자동화하여 의존성을 분리하는 역할을 한다.   
UI 로직 측면에서는 기존에는 ViewModel의 값이 변경되면 일일이 UI를 갱신해야 했지만 DataBinding을 활용하면 데이터의 변화를 즉시 반영하므로 View는 어떻게 그려지는 지를 고려하지 않아도 된다.   
비즈니스 로직 측면에서는 이벤트를 ViewModel 함수에 직접 바인딩하여 View는 클릭 발생 시 어떤 비즈니스 로직이 실행되어야 하는지 알 필요 없이 단순히 이벤트를 전달하는 통로 역할만 수행하면 된다.

### ViewBinding과 DataBinding의 차이점   
ViewBinding과 DataBinding 모두 앱에서 뷰 작업을 할 때 null 안정성 및 효율적으로 레이아웃 요소에 접근하기 위해 안드로이드에서 제공하는 라이브러리이다.

ViewBinding은 findViewById 없이 레이아웃의 뷰에 접근하는 것을 단순화하기 위한 목적을 갖는다.   
각 XML 레이아웃 파일에 대해 바인딩 클래스를 생성하며, 이 클래스에는 id가 있는 모든 뷰에 대한 직접 참조를 제공 -> 타입 안정성 향상 및 보일러 플레이트 감소

| **ViewBinding의 주요 특징**   
+ XML 레이아웃 파일에 대한 바인딩 클래스 생성
+ 레이아웃의 뷰에 대한 직접 참조를 제공하여 findViewById를 사용하지 않고 안전하게 레이아웃 요소에 접근 가능
+ nullable 및 뷰 유형에 대한 컴파일 타임 검사를 제공하여 타입 안정성 보장
+ **바인딩 표현식이나 데이터 기반 업데이트와 같은 고급 기능 제공 X**

| **DataBinding의 주요 특징**   
+ XML에서 UI 요소를 데이터 소스에 바인딩 가능
+ UI 컴포넌트를 동적으로 업데이트하기 위한 바인딩 표혆식 지원
+ UI와 데이터 간의 실시간 동기화를 위한 양방향 데이터 바인딩 제공
+ LiveData 및 StateFlow와 같이 생명주기에 따라 관찰 가능한 타입의 데이터 통합 제공

| **주요 차이점**   
1. 목적 : ViewBinding은 뷰 접근을 단순화, DataBinding은 고급 데이터 기반 UI 바인딩을 가능하게 함
2. 컴파일 타임 클래스 생성 : ViewBinding은 뷰에 대한 직접 참조를 생성, DataBinding은 뷰에 대한 직접 참조뿐만이 아니라 내장 데이터 바인딩 기능이 있는 추가 클래스도 생성
3. 표현식 : ViewBinding은 XML에서 표현식을 지원하지 않지만 DataBinding은 바인딩 표현식과 동적 데이터 바인딩 지원
4. 양방향 바인딩 : DataBinding만 지원
5. 성능 : ViewBinding가 더 빠르고 오버헤드가 적음

# Q53 LiveData에 대해서 설명해 주세요.
LiveData는 Android Jetpack 아키텍처 컴포넌트에서 제공하는 관찰 가능한 데이터 홀더 클래스로 생명주기를 인식하여 Activity, Fragment, View와 같이 연관된 안드로이드 컴포넌트의 생명주기에 따라 동작이 달라진다. 이는 연관된 컴포넌트가 활성 생명주기 상태(started/resumed)일 때만 데이터를 관찰하고 UI를 업데이트할 수 있도록 보장한다.

| **LiveData의 이점**   
1. 생명주기 인식 : LiveData는 컴포넌트의 생명주기를 관찰하고 컴포넌트가 활성 상태일 때만 데이터를 업데이트하여 크래시 및 메모리 누수 위험을 줄인다.
2. 자동 정리 : 컴포넌트에 연결된 관찰자는 주어진 생명주기가 소멸될 때까지 자동으로 제거되고 정리된다.
3. 관찰자 패턴 : UI 컴포넌트는 관찰자를 활용하여 LiveData의 데이터가 변경될 때 자동으로 업데이트된다.
4. 스레드 안정성 : LiveData는 스레드 안전하도록 설계되어 백그라운드 스레드에서 업데이트 가능하다.

| **MutableLiveData와 LiveData의 차이점**   
+ MutableLiveData : `setValue()`또는 `postValue()`를 통해 데이터 수정 허용, 일반적으로 외부에서의 직접적인 수정을 방지하고자 ViewModel 내에서 비공개로 유지
+ LiveData : 외부 컴포넌트가 데이터를 수정하는 것을 방지하는 읽기 전용 버전의 LiveData로 더 나은 캡슐화 보장

| **사용 사례**   
1. UI 상태 관리 : LiveData는 네트워크 응답이나 데이터베이스와 같은 소스의 데이터를 담는 컨테이너 역할을 하여 UI 컴포넌트에 원활하게 바인딩될 수 있도록 한다. 이를 통해 기본 데이터가 변경될 때마다 UI가 자동으로 업데이트되어 인터페이스가 앱 상태와 동기화되도록 보장한다.
2. 관찰자 패턴 구현 : LiveData는 발행자(Publisher) 역할을 하고 Observer 인터페이스가 구독자(Subscriber) 역할을 하는 관찰자 패턴을 따른다. LiveData 값이 변경될 때마다 구독자에게 실시간 업데이트를 용이하게 하여 동적 UI 업데이트/데이터 기반 상호작용 등에 적합하다.
3. 일회성 이벤트 : 토스트 노출, 다른 화면으로 이동하는 one-off 일회성 이벤트에 사용 가능. 단 이때 SingleLiveEvent 또는 유사한 구현으로 커스텀하여 처리

StateFlow의 등장으로 LiveData는 Deprecated 되어야 한다는 주장은 옳지 않다.   
**Flow는 안드로이드와 완전히 독립적인 API로 안드로이드 컴포넌트에 대한 수명주기를 전혀 알지 못한다**   
또한 안드로이드 의존성을 제거하기 위한 Flow 사용도 설득력이 없다.   
모든 Jetpack 관련 라이브러리를 제거하면서까지 JVM 타입의 멀티 모듈 설계를 하는 것을 통해 얻어갈 수 있는 성능적&구조적 이점에 대해선 아직 명확히 밝혀지지 않음!

## 실전 질문
Q) LiveData는 생명주기 인식을 어떻게 보장하며, RxJava 또는 EventBus와 같은 전통적인 observable한 객체와 비교하여 어떤 이점을 제공하나요?   
A) LiveData는 구독 시점에 lifecycle 인스턴스를 결합하여 생명주기를 인식한다. 기존 RxJava, EventBus와 같은 전통적인 observable한 객체와 달리 LiveData는 생명주기에 따라 자동으로 구독을 해제한다.

Q) LiveData에서 setValue()와 postValue()의 차이점은 무엇이며, 각각 언제 사용해야 하나요?   
A) setValue는 메인스레드에서, postValue는 백그라운드 스레드에서 값을 변경한다. 그렇기에 setValue는 즉각 반영되나 postValue는 메인 스레드 큐에 작업을 보내기에 반영이 지연된다. 그렇기에 setValue는 클릭 이벤트 처리, 텍스트 입력 등에 사용되고 postValue는 백그라운드 스레드에서 네트워킹, DB 조회 등의 작업 완료 후에 UI를 갱신해야할 때 사용한다.   

Q) LiveData의 한계는 무엇이며, 구성 변경 시 다시 트리거되지 않고 내비게이션 또는 토스트 메시지 표시와 같은 여러 UI 이벤트를 관찰해야 하는 경우에 어떻게 처리해야 하나요?   
A) LiveData는 항상 최신 값을 가지고 있어 토스트와 같은 일회성 이벤트에서 적합하지 않다. 예를 들어 화면 회전과 같은 configure change시 이미 처리한 이벤트가 재전달되어 중복 실행될 수 있다. 이러한 문제를 해결하기 위해 SingleLiveEvent를 사용할 수 있다.

### LiveData에서 setValue()와 postValue() 메서드의 차이점은 무엇인가요?
+ `setValue()` : 메인 스레드에서만 호출 가능, 값 즉시 갱신, 백그라운드 스레드에서 호출하려고 하면 예외 발생
+ `postValue()` : 데이터를 비동기적으로 업데이트하는데 사용, 백그라운드 스레드서 적합, 호출시 메인스레드에 업데이트 예약, 현재 스레드 차단X(스레드 안정성 보장), 메인 스레드가 작업 개시하기 전에 여러번 호출시 마지막 값만 전달됨

참고   
one-off : 단 한 번만 일어나고 사라져야 하는 것

# Q54 Jetpack ViewModel에 대해 설명해 주세요.
Jetpack ViewModel은 생명주기를 인식하는 방식으로 UI 관련 데이터를 저장하고 관리하도록 설계된 안드로이드 아키텍처 컴포넌트의 핵심 구성 요소.

| **ViewModel의 특징**   
1. 생명주기 인식 : ViewModel은 Activity/Fragment의 생명주기에 범위가 지정되고 UI 컴포넌트가 더이상 사용되지 않을 시 자동으로 소멸한다.
2. 구성 변경 간 지속성 : Configure Change 중에 소멸되고 다시 생성되는 Activity 또는 Fragment와 달리 ViewModel은 상태를 유지하여 데이터 손실을 방지하고 데이터의 반복적인 재로드를 피한다.
3. 관심사 분리 : ViewModel은 UI 관련 로직과 비즈니스 로직을 분리하여 더 깔끔하고 유지 관리하기 쉬운 코드를 설계하는데 도움이 된다. UI 레이어는 ViewModel에서 업데이트를 관찰하므로 반응형 프로그래밍 원칙을 구현하기 수월해진다.

## 실전 질문
Q) ViewModel은 구성 변경 시 데이터를 어떻게 유지하며, onSaveInstanceState()를 사용하여 상태를 저장하는 것과 어떻게 다른가요?   
A) ViewModel은 ViewModelStore 라는 저장소를 통해 구성 변경으로부터 데이터를 유지한다. 반면 onSaveInstanceState()는 데이터를 시스템 서비스의 Bundle에 직렬화하여 저장하기 때문에 저장 용량은 작지만 메모리 부족으로 인한 프로세스 종료(Process Death) 상황에서도 데이터를 복구할 수 있다는 차별점이 있다.

Q) ViewModelStoreOwner의 목적은 무엇이며, 동일한 Activity 내의 여러 Fragment 간에 ViewModel을 어떻게 공유할 수 있나요?   
A) ViewModelStoreOwner는 ViewModelStore를 소유하고 관리하는 주체로 해당 ViewModel의 소유자(Activity나 Fragment)의 생명주기가 완전히 끝날 때 `onCleared()`를 호출하여 리소스 정리를 보장하고 소유자에 따른 Scope를 결정한다.   
동일한 Activity 내의 여러 Fragment 간 ViewModel을 공유하려면 Fragment들이 부모 Activitiy의 ViewModel을 참조하게 하면 된다. `activityViewModels()` 로 간단히 가능.

Q) UI 상태 관리를 위해 ViewModel 내에서 StateFlow 또는 LiveData를 사용하는 것의 장점과 잠재적인 단점은 무엇인가요?   
A) StateFlow, LiveData와 같은 UI 상태 관리 도구를 활용하면 configure change에서도 데이터의 연속성을 보장할 수 있다. 또한, Activity나 Fragment는 데이터를 어떻게 가져오는지를 신경쓰지 않고 던져주는 값을 그리기만 하면 되어 관심사 분리가 용이하다.   
그러나 StateFlow나 LiveData로 모든 UI 변화를 관리하려 하면 지나치게 많은 변수가 생겨 코드가 비대해지고 보일러 플레이트가 증가한다는 문제점이 있다. 또한 이 둘은 기본적으로 상태를 보존하고 있어 일회성 이벤트를 재전달하는 문제가 발생할 수 있다.

### 구성 변경 후에도 ViewModel이 어떻게 유지될 수 있나요?
[내부 코드 분석을 블로그에 올렸다.](https://velog.io/@couch_potato/Android-ViewModel은-어떻게-값을-유지할까)

### Jetpack ViewModel과 Microsoft에서 제시한 MVVM 아키텍처 ViewModel의 차이점에 대해서 설명해 주세요.
**공식문서** : Jetpack ViewModel은 비즈니스 로직 또는 UI State Holder 역할을 하도록 설계된 생명주기를 인식하는 컴포넌트   
**Microsoft MVVM** : ViewModel은 View와 Model 간의 다리 역할, View가 데이터 바인딩할 수 있는 Attribute와 명령을 구현하여 UI에 필요한 기능을 제공한다. 또한 변경 사항에 대한 알림 이벤트를 통해 View에 상태 변경을 알린다. View와 Model 간의 상호 작용을 조정하고 UI에 필요한 비즈니스 로직을 추상화 하거나 호출을 중개하는 역할

| **Jetpack ViewModel과 MVVM ViewModel의 차이점**   
Jetpack ViewModel은 주로 configure change 시 UI 관련 상태 유지에 의의를 두어, 생명주기를 인식하는 UI 상태 관리에 초점을 두지만 MVVM ViewModel은 View와 Model 간 중재자 역할을 하며 바인딩을 처리하고 UI가 ViewModel에서 제공하는 데이터를 표시하는데만 관련되도록 보장한다.

# Q55 Jetpack Navigation 라이브러리란 무엇인가요?
Jetpack Navigation 라이브러리는 앱 내 내비게이션을 단순화하고 표준화하기 위해 안드로이드에서 제공하는 프레임워크로 내비게이션을 관리하는 API, 딥 링크, 백스택 관리, 애니메이션 등의 기능을 제공한다.

+ **Navigation Graph** : 앱 화면 간 내비게이션 흐름과 관계를 정의하는 XML 리소스로 동작의 목적지 등을 정의한다.
+ **NavHostFragment** : 내비게이션 그래프의 컨테이너 역할, 대상을 호스팅하고 대상 간의 내비게이션을 관리한다. -> 말그대로 Fragment가 끼워질 공간을 제공하는 역할로 Fragment를 교체해주는 역할을 수행
+ **NavController** : 내비게이션 작업을 처리하고 백스택을 관리한다. 직접 코드로 목적지 간에 이동하거나 전반적인 내비게이션 흐름을 컨트롤할 수 있다.
+ **Safe Args** : type-safe한 내비게이션 및 인수 전달 코드를 생성하는 Gradle 플러그인으로 대상 간 데이터를 전달할 때 수동으로 번들을 만들 필요 X
+ **Deep Linking** : URL이나 알림과 같은 외부 소스에서 특정 화면으로 직접 이동하도록 한다.

| **Jetpack Navigation 라이브러리의 이점**   
1. 중앙 집중식 내비게이션 : 명확하고 유지 관리 가능한 구조를 위해 모든 내비게이션 흐름을 하나의 XML에서 관리
2. type-safe한 인수 : 생성된 Safe Args 클래스를 통해 대상 간에 데이터를 안전하게 전달
3. 백스택 관리 : 일관된 내비게이션을 위해 백스택 자동으로 처리
4. 딥링크 지원 : 외부 내비게이션 요청 처리로 UX 향상
5. Jetpack Component와 통합 : Fragment, ViewModel, LiveData와 잘 작동하여 생명주기를 고려한 내비게이션 보장

## 실전 질문
Q) Jetpack Navigation 라이브러리는 백 스택을 어떻게 처리하고, NavController로 어떻게 백스택을 조작할 수 있나요?   
A) NavController에 LIFO 구조의 백스택이 존재한다. NavController는 화면 간에 이동할때 백스택에 대상을 추가하거나 제거한다. 먼저 앱을 열면 가장 첫 대상을 백스택의 맨위로 푸시하고 이후 `NavController.navigate()`로 지정 대상을 스택에 푸시한다. 또한 스택에서 제거하고자 한다면 `NavController.popBackStack()`을 통해 팝하여 제거한다.   
만약 특정 지점까지 제거하고자 한다면 `NavOptions`의 `popUpTo`와 `inclusive`속성으로 특정 지점까지 스택을 비울 수 있다.

Q) Safe Arguments란 무엇이며, Jetpack Navigation Component에서 목적 내비게이션 간 데이터를 전달할 때 타입 안전성을 어떻게 보장하나요?   
A) Safe Arguments는 type-safe한 내비게이션 및 인수 전달 코드를 자동으로 생성하는 Gradle 플러그인으로 데이터를 보낼 때 Directions 클래스의 메소드 파라미터를 통해 데이터 타입을 강제하고 받을 때는 `by navArgs()` 위임을 통해 접근 가능하다.

# Q56 Dagger 2와 Hilt의 동작원리 및 차이점에 대해서 설명해 주세요.
| **Dagger 2란?**      
+ 안드로이드 및 JMV 환경을 위한 정적 컴파일 타임 기반의 DI 라이브러리
+ 객체 생성을 관리하고 의존성을 자동으로 제공하여 모듈성을 개선하고 테스트를 용이하게 하도록 설계되었다.
+ 컴파일 타임에 코드 생성

| **Hilt란?**   
+ Dagger 2 위에 구축된 안드로이드 전용 DI 라이브러리
+ Activity, Fragment, ViewModel과 같이 안드로이드 생명주기와 밀접한 관련이 있는 클래스에 스코프가 지정된 사정 정의된 컴포넌트 제공
+ @HiltAndroidApp, @AndroidEntryPoint로 진입점 간소화
+ Hilt로 구현 가능한건 Dagger 2로도 모두 구현 가능

| **Dagger 2와 Hilt의 주요 차이점**   
1. 통합 프로세스 : Dagger 2는 개발자가 컴포넌트와 인젝터를 수동으로 정의해야 하여 보일러 플레이트 코드 유발 가능, Hilt는 사전 정의된 컴포넌트와 생명주기에 스코핑된 어노테이션 제공으로 이를 단순화
2. 안드로이드 생명주기 통합 : Hilt는 안드로이드에 특화, 안드로이드 컴포넌트에 대한 내장 지원을 제공, Dagger 2는 더 범용적이며 생명주기 인식 컴포넌트에 대해 수동 설정 필요
3. 스코핑(Scoping) : Hilt는 @Singleton, @ActivityScope 등 안드로이드 생명주기 클래스와 밀접하게 통합된 사전정의된 scope 제공, Dagger 2는 수동 설정 및 커스텀 어노테이션 필요
4. 코드 단순성 : Hilt는 많은 보일러 플레이트 코드를 추상화하여 러닝 커브다 낮음, Dagger 2는 유연하고 복잡한 구조에서 더 세밀하게 사용 가능하지만 개발자가 직접 정의해야 함
5. 사용 사례 : Dagger 2는 복잡하고 커스텀된 의존성 주입 그래프가 필요한 프로젝트, Hilt는 안드로이드 프로젝트

| **Hilt 및 Dagger 2에서 제공하는 어노테이션**   
**Dagger2 기반(Dagger서 제공, Hilt도 사용)**   
1. `@Inject` : 의존성 주입을 위해 생성자, 필드, 메서드에 표시. 의존성 주입을 실질적으로 **요청**하는데 사용
2. `@Provides` : @Module 내에서 의존성 생성 메서드 정의, 이를 통해 객체를 제공
3. `@Module` : 클래스를 의존성 제공자 컨테이너로 선언, 모듈은 관련된 의존성 생성 로직을 그룹화한다.
4. `@Binds` : @Module 내에서 인터페이스를 구현에 Mapping하는데 사용
5. `@Qualifier` : 커스텀 어노테이션을 사용하여 동일한 타입에 대해 여러 의존성 바인딩을 구별
6. `@Scope` : 특정 의존성의 생명주기를 제어하기 위해 커스텀 스코핑 어노테이션 정의 가능
7. `@Singleton` : 의존성이 해당 범위 내내 단일 공유 인스턴스를 가져야 함을 지정(Dagger2에서는 자동으로 앱 전체기간동안 관리해주지 않음, 여러 번 초기화시 여러 개 생성됨)
8. `@Component` : 의존성 그래프의 인터페이스를 정의, @Component는 모듈을 주입 대상에 연결하고 의존성 생명주기를 제어
9. `@SubComponent` : 지정한 범위 내에서 의존성을 관리하기 위한 케이스를 위해 @Component 내에 더 작은 의존성 그래프 생성, 자체 생명주기를 가진 자식 컴포넌트를 만드는데 사용

@Inject, @Qualifier, @Scope, @Singleton 어노테이션의 경우 Dagger 라이브러리에서 자체적으로 제공하는 것이 아닌 Java 스펙(javax.inject 패키지)에서 제공

| **Hilt에 특화된 어노테이션**   
1. `@HiltAndroidApp` : Hilt를 부트스트랩하고 전체 앱에 대한 의존성 그래프를 생성하기 위해 사용
2. `@AndroidEntryPoint` : 안드로이드 컴포넌트(Activity, Fragment, Service)를 주입 대상으로 마크, 이 어노테이션 사용만 해도 커스텀 Dagger 컴포넌트 정의 필요X
3. `@InstallIn` : @Module이 설치되어야 하는 컴포넌트를 지정
4. `@EntryPoint` : Hilt에서 관리하는 안드로이드 컴포넌트가 아닌 외부에서 의존성에 접근하기 위한 진입점을 정의하는 데 사용
5. `@HiltViewModel` : Jetpack ViewModel을 Hilt와 통합하기 위한 특수 어노테이션, ViewModel이 생명주기를 인식하면서 Hilt의 의존성 주입을 사용할 수 있도록 보장, 생성자에 @Inject 같이 사용해야 함
6. Scope Annotations : 사전 정의된 컴포넌트를 제공하여 특정 라이프 사이클에 의존성을 바인딩하는 프로세스를 단순화

## 실전 질문
Q) Dagger 2와 비교하여 의존성 Hilt는 주입을 어떻게 단순화하고, 안드로이드 애플리케이션에서 Hilt를 사용하는 것의 장점은 무엇인가요?   
A) Dagger 2에서 반본적으로 작성해야 했던 컴포넌트 정의와 초기화 로직을 표준화된 어노테이션으로 자동화하여 단순화했다. Hilt는 안드로이드 전용 DI 라이브러리인 만큼 안드로이드 생명주기에 최적화된 컴포넌트 구조를 자동으로 지원한다는 장점이 있다.   

Q) Dagger와 Hilt에서 @Provides와 @Binds의 차이점은 무엇이고, 각각 언제 사용해야 하나요?   
A) @Provides는 개발자가 직접 클래스 생성 로직을 제어해아 하거나 추가적인 설정이 필요할 때 사용하고 @Binds는 인터페이스와 그 구현체를 매핑할 때 사용한다. 그런만큼 @Binds가 더 가볍고 효율적이므로 직접 생성 로직을 제어해야 한다면 @Provides를 그렇지 않고 생성자 주입이 가능한 상황이라면 @Binds를 사용하는 것이 바람직하다.

Q) Hilt에서 @Singleton, @ActivityScoped, @ViewModelScoped를 사용하면 내부적으로 스코핑이 어떻게 작동하는지 매커니즘을 설명하고, 해당 스코프가 사용되면 애플리케이션 내 의존성의 수명을 어떻게 관리하는지 설명해 주세요.   
A) Hilt의 스코핑 매커니즘은 특정 객체를 안드로이드 컴포넌트의 생명주기와 결합된 전용 컨테이너에 캐싱하는 방식으로 작동한다. @Singleton은 SingletonComponent에 인스턴스를 저장하여 전역적으로 공유하고 @ActivityScoped는 개별 액티비티 인스턴스의 생명주기 동안만 동일한 객체를 반환한다. @ViewModelScoped는 Jetpack ViewModel의 특징을 따라 configure change 시에도 파괴되지 않고 유지된다.

### Dagger 2 및 Hilt 이외에 DI 라이브러리
| **Koin**   
+ 어노테이션 처리 없음 : 의존성은 Kotlin 코드로 정의되어 어노테이션 처리를 피하고 빌드 시간을 단축한다.
+ Kotlin 우선 접근 방식 : Kotlin DSL을 사용하여 DI 구성을 읽기 쉽고 직관적으로 만든다.
+ 사용 편의성 : 설정이 빠르고 소규모 프로젝트/빠른 DI 환경 셋업을 추구하는 개발자에게 이상적
+ 동적 해결 : 런타임시 의존성이 결정되는 시나리오에서 유용한 동적 의존성 솔루션 지원

참고   
+ 부트스트랩(Bootstrap) : 시스템이 작동하기 위한 최소한의 준비를 갖추고 엔진을 가동하는 과정

# Q57 Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?
Jetpack Paging 라이브러리는 대규모 데이터 셋을 청크 또는 "페이지" 단위로 로드하고 표시하는 프로세스를 돕도록 설계된 안드로이드 아키텍처 컴포넌트이다.

| **Paging 라이브러리의 구성 요소**   
1. PagingData : 점진적으로 로드되는 데이터 스트림, RecyclerView와 같은 UI 컴포넌트에 의해 관찰되고 사용 가능
2. PagingSource : 데이터 소스에서 데이터가 로드되는 방식을 정의하는 역할을 한다. 위치/ID와 같은 키 값을 기반으로 데이터 페이지를 로드하는 메서드를 제공한다.
3. Pager : PagingSource와 PagingData 간의 중개자 역할을 한다. PagingData 스트림의 생명주기를 관리하다.
4. RemoteMediator : 로컬 캐싱과 원격 API 데이터를 결합할 때 경계 조건을 구현하는데 사용된다.

| **Paging 라이브러리 작동 방식**   
1. PagingSource를 정의하여 데이터를 가져오는 방법을 지정한다.
2. Pager를 사용하여 PagingData의 Flow를 생성한다.
3. ViewModel에서 PagingData를 관찰하고 RecyclerView에서 렌더링하기 위해 PagingDataAdaptre에 전달한다.