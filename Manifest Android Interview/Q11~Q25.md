# Q11 상태(State)란 무엇이며 이를 관리하는 데 사용되는 API는 무엇인가요?   
Jetpack Compose에서 State는 앱 시나리오에서 흔히 변경될 수 있는 값이자 UI에서 동적으로 반영되는 메시지를 나타낸다.   

| **State와 Composition**      
+ 초기 Composition : 컴포저블을 실행하여 UI 트리가 처음 생성되고 렌더링되는 프로세스
+ Recomposition : 상태 변경시 트리거되며 recomposition은 관련 컴포저블을 업데이트하여 새로운 상태를 반영한다.

| **Compose에서 상태 관리하기**   
Jetpack Compose는 상태를 효과적으로 관리하기 위해 여러 API 들을 제공한다.   
1. **remember** : 초기 컴포지션이 발생했을 때 메모리에 객체를 저장하고 recomposition이 발생하면 기존 메모리에 저장된 값을 꺼내온다.
2. **rememberSaveable** : recomposition 뿐만이 아닌 configure change에서도 상태 유지, Bundle에 저장할 수 있는 유형 또는 그 외 유형에 대해서는 커스텀 saver 객체와 함께 작동 가능
3. **mutableStateOf** : 가변적인 상태를 의미, 상태 값이 변경될 때 recompositoin을 트리거하는 관찰 가능한 상태 객체를 생성

## 실전 질문
Q) 상태는 recomposition과 어떤 관련이 있으며, recomposition이 발생하면 내부적으로 어떤 일이 발생하나요?   
A) State는 상태값이 변경될 떄 recomposition을 트리거한다. recomposition이 발생하면 슬롯테이블에 저장된 값과 비교하여 변경된 부분만 골라 새롭게 UI를 업데이트한다.

# Q12 상태 호이스팅(state hoisting)으로 어떤 이점을 얻을 수 있나요?
상태 호이스팅은 상태를 상위 수준의 컴포저블 함수로 끌어올리는 것을 의미한다.   
Hoisting은 무언가를 위쪽으로 끌어올리는 것을 의미   

**상태 호이스팅의 특성**   
+ State는 부모 컴포저블에서 관리한다 -> 상태 호이스팅을 적용하려는 컴포저블은 상태 자체를 가져선 안되고 매개변수로 상태를 받아서도 안된다.
+ Events 또는 triggers(onClick 등)는 자식에서 값을 바꾸고, 해당 값을 부모로 다시 전달받는 형태로 상태를 업데이트한다 -> 보편적으로 람다 함수를 매개변수로 넘기고 해당 컴포저블을 호출하는 쪽에서 업데이트된 값을 콜백으로 받아 상태를 업데이트시키는 형태로 동작
+ 업데이트된 상태는 매개변수로 자식에게 다시 전달되어 단방향 데이터 흐름을 생성

| **상태 호이스팅의 장점**   
+ **더 나은 재사용성** : 상태 호이스팅을 적용하여 stateless 및 재사용 가능한 컴포저블 생성 가능
+ **단순화된 테스트**
+ **더 나은 관심사 분리**
+ **단방향 데이터 흐름 지원**
+ **향상된 상태 관리**

## 실전 질문
Q) 상태 호이스팅이 왜 컴포저블 함수의 재사용성과 테스트 용이성을 향상시키나요? 예시를 들어서 설명해 주세요.   
A) 텍스트 입력 컴포넌트를 예시로 들면 텍스트 상태값을 해당 컴포저블이 갖고 있다면 초기 텍스트 값이 동일하고 텍스트 변경 함수 또한 기능이 제한되어 늘 동일한 용도로만 사용해야 한다. 그러나 상태 호이스팅을 사용한다면 초기 텍스트를 필요한 레이아웃마다 지정해줄 수 있고 텍스트 변경 이벤트(onValueChange 등)도 커스텀 가능하여 보다 다양한 용도로 사용할 수 있다.   
또한 테스트는 '내가 준 입력에 기대한 출력이 나오는가'가 핵심으로 상태 호이스팅을 사용한다면 직접 UI 이벤트를 발생시키지 않고 파라미터에 단순히 테스트용 텍스트 데이터를 전달하는 것으로 검증이 가능하다.

Q) 어떤 시나리오에서 상태 호이스팅을 사용하지 않고, 컴포저블 내부에 상태를 갖도록 하실 건가요? 해당 시나리오에서는 컴포저블에 상태를 갖도록 하는 것이 상태 호이스팅을 적용하는 것에 비해 어떤 장점을 갖나요?   
A) 비즈니스 로직이 배제된 순수 UI 상태(ex. 하이라이트 효과, 드롭다운 상태 등)과 애니메이션 상태의 경우 상태 호이스팅을 지양한다. 이러한 시나리오에서 컴포저블에 상태를 갖게함으로서 UI 적인 부분에 대해서 캡슐화를 해줄 수 있고 오히려 재사용성도 개선된다.

# Q13 remember와 rememberSaveable의 차이점은 무엇인가요?
| **remember 이해하기**   
+ 목적 : 메모리에 값을 저장하고 recomposition이 발생했을 경우 메모리에 저장된 값을 꺼내와 상태를 유지. 그러나 configure change 중에는 상태 유지 X
+ UseCase : 상태가 configure change 후에도 유지될 필요가 없을 때

| **rememberSaveable 이해하기**   
+ 목적 : configure change 시에도 상태를 유지. 안드로이드 SDK의 Bundle에 저장할 수 있는 값에 한하여 자동으로 저장하고 복원
+ UseCase : 유저 input 입력이나 내비게이션 상태 등 configure change 후에도 유지되어야할 때

| **사용 시기**   
+ 애니메이션이나 임시적인 UI 상태와 같이 현재 컴포지션을 넘어서 유지될 필요가 없는 일시적인 상태에는 remember
+ 사용자 입력, 선택 상태 또는 양식 데이터와 같이 구성 변경 시에도 유지되어 더 나은 UX를 제공할 수 있는 상태에는 rememberSaveable

## 실전 질문
Q) remember이 아닌 rememberSaveable를 사용해야하는 시나리오는 무엇이며, 어떤 트레이드오프를 고려해야 하나요?   
A) Configure Change에서도 반드시 상태를 저장해야할 때 적합하다. 그러나 내부적으로 Bundle 메커니즘을 사용하여 데이터 크기에 제한이 있고 커스텀 객체는 별도의 Saver를 구현해야 한다.

### remember 및 rememberSaveable 내부 구조
| **remember 내부 구조 이해하기**   
https://velog.io/@couch_potato/Android-remember는-어떻게-값을-기억할까

| **rememberSaveable 내부 구조 이해하기**   
1. **키 생성** : key 매개변수를 통해 사용자가 커스텀 키를 제공 가능, 제공되지 않으면 현재 컴포지션 해시를 사용하여 복합키가 자동 생성됨
2. **상태 복원** : LocalSaveableStateRegistry로 주어진 키에 대해 이전의 저장된 값을 검색하고 저장된 값이 존재하면 제공된 Saver를 사용하여 복원
3. **기본값 초기화** : 복원된 값이 없으면 init 람다를 통해 기본값 초기화
4. **Saveable Holder** : 상태, saver, registry 및 입력 관리를 위한 SaveableHolder 생성
5. **입력 변경 처리** : rememberSaveable에 대한 입력이 변경되면 상태가 무효화되고 값이 다시 초기화된다.
6. **사이드 이펙트** : SideEffect는 recomposition 중에 업데이트된 상태가 Registry에 저장되도록 보장한다.


