# 부록
객체지향 세계에서 개념을 가리키는 표준 용어는 **타입**이다.

분류는 객체와 타입 간의 관계를 나타내는 것이다.

타입을 객체의 분류 장치로서 적용하기 위해서는 다음과 같은 3가지 관점에서의 정의가 필요하다.
+ 심볼 : 타입을 가리키는 간략한 이름이나 명칭
+ 내연 : 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
+ 외연 : 타입에 속하는 모든 객체들의 집합

**단일 분류** : 한 객체가 한 시점에 하나의 타입에만 속하는 것
**다중 분류** : 한 객체가 한 시점에 여러 타입에 속하는 것

일반적으로 객체지향 프로그래밍 언어들은 단일 분류만을 지원   
다중 분류 != 다중 상속

**동적 분류** : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
**정적 분류** : 객체자 자신의 타입을 변경할 수 없는 경우

객체 지향 프로그래밍 언어에서 다중 분류와 동적 분류를 구현에 옮기는 것은 어려움.   
다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 것이 현실적인 방법

어떤 타입이 다른 타입의 서브타입이 되기 위해서는 **100% 규칙**과 **is-a 규칙**을 준수해야 한다.   
+ 100% 규칙 : 슈퍼타입의 정의가 100% 서브타입에 적용되어야 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.   
+ is-a 규칙 : 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 서브타입 is a 슈퍼타입이라는 구문으로 테스트 가능.

일반화 관계를 is-a 관계라고 흔히 표현한다.

## 상속
프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 사용하는 것이다.

유념할 부분은 모든 상속 관계가 일반화 관계인 것은 아니다.

한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 **순응**해야 한다.   
순응은 다음과 같이 2종류가 있다.   
+ 구조적인 순응 : 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.
+ 행위적인 순응 : 서브타입은 슈퍼타입을 행위적으로 대체 가능해아 한다. -> **리스코프 치환 원칙**

상속은 서브타이핑(subtyping)과 서브클래싱(subclassing)의 2가지 용도로 사용될 수 있다.
+ 서브타이핑 : 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 -> 설계의 유연성이 목표 -> **인터페이스 상속**
+ 서브클래싱 : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우 -> 코드의 중복 제거와 재사용 목적 -> **구현 상속**

메시지를 수신한 객체는 자신이 메시지를 이해할 수 없는 경우, 이를 부모 객체에 위임한다.   
이 사슬은 메시지를 처리하거나 최상위 부모 객체에게 위임될 때까지 계속 된다.

## 집합과 분해
+ 복잡성은 계층의 형태를 띤다.
+ 단순한 형태로부터 복잡한 형태로 진화하는데 걸리는 시간은 그 사이에 존재하는 안정적인 형태의 수와 분포에 의존한다.

안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**이라고 하고 이와 반대로 전체를 부분으로 분할하는 행위를 **분해**라고 한다.

집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.

## 합성 관계
객체와 객체 사이의 전체-부분 관계를 구현하기 위해 합성 관계를 사용한다.

합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.



