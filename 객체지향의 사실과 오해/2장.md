# 2장
객체지향을 설명할 때 흔히 현실 세계의 객체를 소프트웨어로서의 모방한다고 예시를 든다.   
그러나 실제 소프트웨어 세계에서의 객체는 현실 세계의 객체와 전혀 다른 모습을 보인다.

### 객체
객체는 **상태**, **행동**, **식별자**를 지닌 실체이다.

### 상태
특정 시점에 객체가 가지고 있는 정보의 집합   
객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성   
프로퍼티는 단순한 값인 **속성(attribute)** 와 객체와의 연결인 **링크(link)** 의 조합으로 표현할 수 있다.

### 행동
객체의 행동은 객체 자신의 상태를 변경시킨다.   
즉, 객체의 행동이 **부수 효과(side effect)** 를  초래한다는 것을 의미한다.

#### 상태와 행동
+ 객체의 행동은 상태에 영향을 받는다.
+ 객체의 행동은 상태를 변경시킨다.

#### 협력과 행동
객체는 협력에 참여하는 과정에서 스스로의 상태뿐만 아니라 다른 객체의 상태 변경을 유발할 수 있다.
+ 객체 자신의 상태 변경
+ 행동 내에서 협력하는 다른 객체에 대한 메시지 전송   

-> 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어 햔다.   
> 개인적인 감상으로 이것은 흔히 외부와의 상호작용(여기서는 협력)을 위해 객체가 public한 외부에 노출된 함수를 갖는 것을 의미하는 것이라 받아들였다.

#### 상태 캡슐화
객체가 외부에 노출하는 것은 행동 뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.   
객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태 변경에 대한 것은 객체만 알 수 있다.

상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.   
이것이 상태를 캡슐화해야 하는 이유이다.

### 식별자
모든 객체는 식별 가능하고 이를 위한 특정한 프로퍼티를 **식별자**라고 한다.

동등성(equality) : 상태를 이용해 두 값이 같은지 판단할 수 있는 성질   
동일성(identical) : 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질

상태를 기반으로 객체의 동일성을 판단할 수 없는 이유 -> 시간이 흐름에 따라 객체의 상태가 변하기 때문

**쿼리(query)** : 객체의 상태를 조회하는 작업   
**명령(command)** : 객체의 상태를 변경하는 작업

## 행동이 상태를 결정한다.
객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이라고 한다.   
초보자들은 객체에 필요한 상태가 무엇인지를 결정하고 그 상태에 필요한 행동을 결정한다.

이 책에서 이러한 방법은 설계에 나쁜 영향을 끼친다고 한다.   
1. 상태를 먼저 결정할 경우 캡슐화가 저해된다.
   + 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.
2. 객체를 협력자가 아닌 고립된 섬으로 만든다.
   + 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 한다.
3. 객체의 재사용성이 저하된다.
   + 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵다.

객체의 행동은 객체가 협력에 참여하는 유일한 방법이다.   
그렇기에 객체가 적합한지를 결정하는 것은 객체의 상태가 아닌 행동이다.   

협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다.   
어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.

## 은유와 객체
현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은   
현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것이다.

레베카 워프스브록은 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 **의인화**라고 부른다.

현실과 객체지향 세계의 관계를 보다 정확하게 설명할 수 있는 단어는 **은유(metaphor)** 이다.   
소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다.